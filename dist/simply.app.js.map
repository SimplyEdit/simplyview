{
  "version": 3,
  "sources": ["../src/route.mjs", "../src/command.mjs", "../src/action.mjs", "../src/key.mjs", "../src/state.mjs", "../src/bind.mjs", "../src/app.mjs"],
  "sourcesContent": ["export function routes(options) {\n\treturn new SimplyRoute(options)\n}\n\nclass SimplyRoute {\n\tconstructor(options={}) {\n\t\tthis.root = options.root || '/'\n        this.app = options.app\n\t\tthis.clear()\n\t\tif (options.routes) {\n\t\t\tthis.load(options.routes)\n\t\t}\n\t}\n\n\tload(routes) {\n\t\tparseRoutes(routes, this.routeInfo)\n\t}\n\n\tclear() {\n\t\tthis.routeInfo = []\n\t\tthis.listeners = {\n\t\t\tmatch: {},\n\t\t\tcall: {},\n\t\t\tfinish: {}\n\t\t}\n\t}\n\n\tmatch(path, options) {\n\t\tlet args = {\n            path,\n            options\n        }\n        args = this.runListeners('match',args)\n        path = args.path ? args.path : path;\n\n        let matches;\n        if (!path) {\n            if (this.match(document.location.pathname+document.location.hash)) {\n                return true;\n            } else {\n                return this.match(document.location.pathname);\n            }\n        }\n        path = getPath(path);\n        for ( let route of this.routeInfo) {\n            matches = route.match.exec(path)\n            if (matches && matches.length) {\n                var params = {};\n                route.params.forEach((key, i) => {\n                    if (key=='*') {\n                        key = 'remainder'\n                    }\n                    params[key] = matches[i+1]\n                })\n                Object.assign(params, options)\n                args.route = route\n                args.params = params\n                args = this.runListeners('call', args)\n                params = args.params ? args.params : params\n                args.result = route.action.call(route, params)\n                this.runListeners('finish', args)\n                return args.result\n            }\n        }\n        if (path && path[path.length-1]!='/') {\n        \treturn this.match(path+'/', options)\n        }\n        return false\n\t}\n\n\trunListeners(action, params) {\n        if (!Object.keys(this.listeners[action])) {\n            return\n        }\n        Object.keys(this.listeners[action]).forEach((route) => {\n            var routeRe = getRegexpFromRoute(route);\n            if (routeRe.exec(params.path)) {\n                var result;\n                for (let callback of this.listeners[action][route]) {\n                    result = callback.call(this.app, params)\n                    if (result) {\n                        params = result\n                    }\n                }\n            }\n        })\n        return params\n    }\n\n    handleEvents() {\n        globalThis.addEventListener('popstate', () => {\n            if (this.match(getPath(document.location.pathname + document.location.hash, this.root)) === false) {\n                this.match(getPath(document.location.pathname, this.root))\n            }\n        })\n        globalThis.document.addEventListener('click', (evt) => {\n\t        if (evt.ctrlKey) {\n\t            return;\n\t        }\n\t        if (evt.which != 1) {\n\t            return; // not a 'left' mouse click\n\t        }\n\t        var link = evt.target;\n\t        while (link && link.tagName!='A') {\n\t            link = link.parentElement;\n\t        }\n\t        if (link \n\t            && link.pathname \n\t            && link.hostname==globalThis.location.hostname \n\t            && !link.link\n\t            && !link.dataset.simplyCommand\n\t        ) {\n\t            let path = getPath(link.pathname+link.hash, this.root);\n\t            if ( !this.has(path) ) {\n\t                path = getPath(link.pathname, this.root);\n\t            }\n\t            if ( this.has(path) ) {\n\t                let params = this.runListeners('goto', { path: path});\n\t                if (params.path) {\n\t                    this.goto(params.path);\n\t                }\n\t                evt.preventDefault();\n\t                return false;\n\t            }\n\t        }\n\t    })\n    }\n\n    goto(path) {\n        history.pushState({},'',getURL(path))\n        return this.match(path)\n    }\n\n    has(path) {\n    \tpath = getPath(path, this.root)\n    \tfor (let route of this.routeInfo) {\n            var matches = route.match.exec(path)\n            if (matches && matches.length) {\n                return true\n            }\n        }\n        return false\n    }\n\n    addListener(action, route, callback) {\n        if (['goto','match','call','finish'].indexOf(action)==-1) {\n            throw new Error('Unknown action '+action)\n        }\n        if (!this.listeners[action][route]) {\n            this.listeners[action][route] = []\n        }\n        this.listeners[action][route].push(callback)\n    }\n\n    removeListener(action, route, callback) {\n        if (['match','call','finish'].indexOf(action)==-1) {\n            throw new Error('Unknown action '+action)\n        }\n        if (!this.listeners[action][route]) {\n            return\n        }\n        this.listeners[action][route] = this.listeners[action][route].filter((listener) => {\n            return listener != callback\n        })\n    }\n\n    init(options) {\n    \tif (options.root) {\n    \t\tthis.root = options.root\n    \t}\n    }\n}\n\nfunction getPath(path, root='/') {\n    if (path.substring(0,root.length)==root\n        ||\n        ( root[root.length-1]=='/' \n            && path.length==(root.length-1)\n            && path == root.substring(0,path.length)\n        )\n    ) {\n        path = path.substring(root.length)\n    }\n    if (path[0]!='/' && path[0]!='#') {\n        path = '/'+path\n    }\n    return path\n}\n\nfunction getURL(path, root) {\n    path = getPath(path, root)\n    if (root[root.length-1]==='/' && path[0]==='/') {\n        path = path.substring(1)\n    }\n    return root + path;\n}\n\nfunction getRegexpFromRoute(route) {\n    return new RegExp('^'+route.replace(/:\\w+/g, '([^/]+)').replace(/:\\*/, '(.*)'));\n}\n\nfunction parseRoutes(routes) {\n    let routeInfo = []\n    const paths = Object.keys(routes)\n    const matchParams = /:(\\w+|\\*)/g\n    for (let path of paths) {\n        let matches = []\n        let params  = []\n        do {\n            matches = matchParams.exec(path)\n            if (matches) {\n                params.push(matches[1])\n            }\n        } while(matches)\n        routeInfo.push({\n            match:  getRegexpFromRoute(path),\n            params: params,\n            action: routes[path]\n        })\n    }\n    return routeInfo\n}\n", "class SimplyCommands {\n\tconstructor(options={}) {\n\t\tif (!options.app) {\n\t\t\toptions.app = {}\n\t\t}\n\t\tif (!options.app.container) {\n\t\t\toptions.app.container = document.body\n\t\t}\n\t\tthis.app = options.app\n\t\tthis.handlers = options.handlers || defaultHandlers\n\t\tthis.commands = options.commands || {}\n\n\t\tconst commandHandler = (evt) => {\n\t\t\tconst command = getCommand(evt, this.handlers)\n\t\t\tif (!command) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (!this.commands[command.name]) {\n                console.error('simply.command: undefined command '+command.name, command.source);\n                return\n\t\t\t}\n\t\t\tthis.commands[command.name].call(this.app, command.source, command.value)\n\t\t}\n\n        function stop(fn) {\n            return (evt) => {\n                fn(evt)\n                evt.preventDefault()\n                evt.stopPropagation()\n                return false                \n            }\n        }\n\n        this.app.container.addEventListener('click', stop(commandHandler))\n        this.app.container.addEventListener('submit', stop(commandHandler))\n        this.app.container.addEventListener('change', commandHandler)\n        this.app.container.addEventListener('input', commandHandler)\n\t}\n}\n\nexport function commands(options={}) {\n\treturn new SimplyCommands(options)\n}\n\nfunction getCommand(evt, handlers) {\n    var el = evt.target.closest('[data-simply-command]')\n    if (el) {\n        for (var i=handlers.length-1; i>=0; i--) {\n            if (el.matches(handlers[i].match)) {\n                if (handlers[i].check(el, evt)) {\n                    return {\n                        name:   el.dataset.simplyCommand,\n                        source: el,\n                        value:  handlers[i].get(el)\n                    }\n                }\n            }\n        }\n    }\n    return null;\n}\n\nconst defaultHandlers = [\n    {\n        match: 'input,select,textarea',\n        get: function(el) {\n            if (el.tagName==='SELECT' && el.multiple) {\n                let values = []\n                for (let option of el.options) {\n                    if (option.selected) {\n                        values.push(option.value)\n                    }\n                }\n                return values\n            }\n            return el.dataset.simplyValue || el.value\n        },\n        check: function(el, evt) {\n            return evt.type=='change' || (el.dataset.simplyImmediate && evt.type=='input')\n        }\n    },\n    {\n        match: 'a,button',\n        get: function(el) {\n            return el.dataset.simplyValue || el.href || el.value\n        },\n        check: function(el,evt) {\n            return evt.type=='click' && evt.ctrlKey==false && evt.button==0\n        }\n    },\n    {\n        match: 'form',\n        get: function(el) {\n            let data = {}\n            for (let input of Array.from(el.elements)) {\n                if (input.tagName=='INPUT' \n                    && (input.type=='checkbox' || input.type=='radio')\n                ) {\n                    if (!input.checked) {\n                        return;\n                    }\n                }\n                if (data[input.name] && !Array.isArray(data[input.name])) {\n                    data[input.name] = [data[input.name]]\n                }\n                if (Array.isArray(data[input.name])) {\n                    data[input.name].push(input.value)\n                } else {\n                    data[input.name] = input.value\n                }\n            }\n            return data\n        },\n        check: function(el,evt) {\n            return evt.type=='submit'\n        }\n    },\n    {\n    \tmatch: '*',\n        get: function(el) {\n            return el.dataset.simplyValue\n        },\n        check: function(el, evt) {\n            return evt.type=='click' && evt.ctrlKey==false && evt.button==0\n        }\n    }\n]", "class SimplyActions {\n\tconstructor(options) {\n        this.app = options.app\n        \n\t\tconst actionHandler = {\n\t\t\tget: (target, property) => {\n\t\t\t\treturn target[property].bind(this.app)\n\t\t\t}\n\t\t}\n\n\t\tthis.actions = new Proxy({}, actionHandler)\n\t\tObject.assign(this.actions, options.actions)\n\t}\n}\n\nexport function actions(options) {\n\treturn new SimplyActions(options)\n}", "class SimplyKeys {\n\tconstructor(options = {} ) {\n\t\tif (!options.app) {\n\t\t\toptions.app = {}\n\t\t}\n\t\tif (!options.app.container) {\n\t\t\toptions.app.container = document.body\n\t\t}\n\t\tthis.app = options.app\n\t\tthis.app.container.addEventListener('keydown', keyHandler(this.keys))\n\t}\n}\n\nexport function keys(options={}) {\n\treturn new SimplyKeys(options)\n}\n\nfunction keyHandler(keys) {\n\treturn (e) => {\n\t\tif (e.isComposing || e.keyCode === 229) {\n\t\t    return;\n\t\t}\n\t\tif (e.defaultPrevented) {\n\t\t    return;\n\t\t}\n\t\tif (!e.target) {\n\t\t    return;\n\t\t}\n\n\t\tlet selectedKeyboard = 'default';\n\t\tif (e.target.closest('[data-simply-keyboard]')) {\n\t\t    selectedKeyboard = e.target.closest('[data-simply-keyboard]').dataset.simplyKeyboard;\n\t\t}\n\t\tlet key = '';\n\t\tif (e.ctrlKey && e.keyCode!=17) {\n\t\t    key+='Control+';\n\t\t}\n\t\tif (e.metaKey && e.keyCode!=224) {\n\t\t    key+='Meta+';\n\t\t}\n\t\tif (e.altKey && e.keyCode!=18) {\n\t\t    key+='Alt+';\n\t\t}\n\t\tif (e.shiftKey && e.keyCode!=16) {\n\t\t    key+='Shift+';\n\t\t}\n\t\tkey+=e.key;\n\n\t\tif (keys[selectedKeyboard] && keys[selectedKeyboard][key]) {\n\t\t    let keyboard = keys[selectedKeyboard]\n\t\t    keyboard.app = keys.app;\n\t\t    keyboard[key].call(keys.app,e);\n\t\t}\n\t}\n}", "const source = Symbol('source')\nconst iterate = Symbol('iterate')\n\nconst signalHandler = {\n    get: (target, property, receiver) => {\n        if (property===source) {\n            return target // don't notifyGet here, this is only called by set\n        }\n        const value = target?.[property] // Reflect.get fails on a Set.\n        notifyGet(receiver, property)\n        if (typeof value === 'function') {\n            if (Array.isArray(target)) {\n                return (...args) => {\n                    let l = target.length\n                    // by binding the function to the receiver\n                    // all accesses in the function will be trapped\n                    // by the Proxy, so get/set/delete is all handled\n                    let result = value.apply(receiver, args)\n                    if (l != target.length) {\n                        notifySet(receiver,  makeContext('length', { was: l, now: target.length }) )\n                    }\n                    return result\n                }\n            } else if (target instanceof Set || target instanceof Map) {\n                return (...args) => {\n                    // node doesn't allow you to call set/map functions\n                    // bound to the receiver.. so using target instead\n                    // there are no properties to update anyway, except for size\n                    let s = target.size\n                    let result = value.apply(target, args)\n                    if (s != target.size) {\n                        notifySet(receiver, makeContext( 'size', { was: s, now: target.size }) )\n                    }\n                    // there is no efficient way to see if the function called\n                    // has actually changed the Set/Map, but by assuming the\n                    // 'setter' functions will change the results of the\n                    // 'getter' functions, effects should update correctly\n                    if (['set','add','clear','delete'].includes(property)) {\n                        notifySet(receiver, makeContext( { entries: {}, forEach: {}, has: {}, keys: {}, values: {}, [Symbol.iterator]: {} } ) )\n                    }\n                    return result\n                }\n            } else {\n                // support custom classes, hopefully\n                return value.bind(receiver)\n            }\n        }\n        if (value && typeof value == 'object') {\n            //NOTE: get now returns a signal, set doesn't 'unsignal' the value set\n            return signal(value)\n        }\n        return value\n    },\n    set: (target, property, value, receiver) => {\n        value = value?.[source] || value // unwraps signal\n        let current = target[property]\n        if (current!==value) {\n            target[property] = value\n            notifySet(receiver, makeContext(property, { was: current, now: value } ) )\n        }\n        if (typeof current === 'undefined') {\n            notifySet(receiver, makeContext(iterate, {}))\n        }\n        return true\n    },\n    has: (target, property) => { // receiver is not part of the has() call\n        let receiver = signals.get(target) // so retrieve it here\n        if (receiver) {\n            notifyGet(receiver, property)\n        }\n        return Object.hasOwn(target, property)\n    },\n    deleteProperty: (target, property) => {\n        if (typeof target[property] !== 'undefined') {\n            let current = target[property]\n            delete target[property]\n            let receiver = signals.get(target) // receiver is not part of the trap arguments, so retrieve it here\n            notifySet(receiver, makeContext(property,{ delete: true, was: current }))\n        }\n        return true\n    },\n    defineProperty: (target, property, descriptor) => {\n        if (typeof target[property] === 'undefined') {\n            let receiver = signals.get(target) // receiver is not part of the trap arguments, so retrieve it here\n            notifySet(receiver, makeContext(iterate, {}))\n        }\n        return Object.defineProperty(target, property, descriptor)\n    },\n    ownKeys: (target) => {\n        let receiver = signals.get(target) // receiver is not part of the trap arguments, so retrieve it here\n        notifyGet(receiver, iterate)\n        return Reflect.ownKeys(target)\n    }\n\n}\n\n/**\n * Keeps track of the return signal for an update function, as well\n * as signals connected to other objects. \n * Makes sure that a given object or function always uses the same\n * signal\n */\nconst signals = new WeakMap()\n\n/**\n * Creates a new signal proxy of the given object, that intercepts get/has and set/delete\n * to allow reactive functions to be triggered when signal values change.\n */\nexport function signal(v) {\n    if (!signals.has(v)) {\n        signals.set(v, new Proxy(v, signalHandler))\n    }\n    return signals.get(v)\n}\n\nlet batchedListeners = new Set()\nlet batchMode = 0\n/**\n * Called when a signal changes a property (set/delete)\n * Triggers any reactor function that depends on this signal\n * to re-compute its values\n */\nfunction notifySet(self, context={}) {\n    let listeners = []\n    context.forEach((change, property) => {\n        let propListeners = getListeners(self, property)\n        if (propListeners?.length) {\n            for (let listener of propListeners) {\n                addContext(listener, makeContext(property,change))\n            }\n            listeners = listeners.concat(propListeners)\n        }\n    })\n    listeners = new Set(listeners.filter(Boolean))\n    if (listeners) {\n        if (batchMode) {\n            batchedListeners = batchedListeners.union(listeners)\n        } else {\n            const currentEffect = computeStack[computeStack.length-1]\n            for (let listener of Array.from(listeners)) {\n                if (listener!=currentEffect && listener?.needsUpdate) {\n                    listener()\n                }\n                clearContext(listener)\n            }\n        }\n    }\n}\n\nfunction makeContext(property, change) {\n    let context = new Map()\n    if (typeof property === 'object') {\n        for (let prop in property) {\n            context.set(prop, property[prop])\n        }\n    } else {\n        context.set(property, change)\n    }\n    return context\n}\n\nfunction addContext(listener, context) {\n    if (!listener.context) {\n        listener.context = context\n    } else {\n        context.forEach((change,property)=> {\n            listener.context.set(property, change) // TODO: merge change if needed\n        })\n    }\n    listener.needsUpdate = true\n}\n\nfunction clearContext(listener) {\n    delete listener.context\n    delete listener.needsUpdate\n}\n\n/**\n * Called when a signal property is accessed. If this happens\n * inside a reactor function--computeStack is not empty--\n * then it adds the current reactor (top of this stack) to its\n * listeners. These are later called if this property changes\n */\nfunction notifyGet(self, property) {\n    let currentCompute = computeStack[computeStack.length-1]\n    if (currentCompute) {\n        // get was part of a react() function, so add it\n        setListeners(self, property, currentCompute)\n    }\n}\n\n/**\n * Keeps track of which update() functions are dependent on which\n * signal objects and which properties. Maps signals to update fns\n */\nconst listenersMap = new WeakMap()\n\n/**\n * Keeps track of which signals and properties are linked to which\n * update functions. Maps update functions and properties to signals\n */\nconst computeMap = new WeakMap()\n\n/**\n * Returns the update functions for a given signal and property\n */\nfunction getListeners(self, property) {\n    let listeners = listenersMap.get(self)\n    return listeners ? Array.from(listeners.get(property) || []) : []\n}\n\n/**\n * Adds an update function (compute) to the list of listeners on\n * the given signal (self) and property\n */\nfunction setListeners(self, property, compute) {\n    if (!listenersMap.has(self)) {\n        listenersMap.set(self, new Map())\n    }\n    let listeners = listenersMap.get(self)\n    if (!listeners.has(property)) {\n        listeners.set(property, new Set())\n    }\n    listeners.get(property).add(compute)\n\n    if (!computeMap.has(compute)) {\n        computeMap.set(compute, new Map())\n    }\n    let connectedSignals = computeMap.get(compute)\n    if (!connectedSignals.has(property)) {\n        connectedSignals.set(property, new Set)\n    }\n    connectedSignals.get(property).add(self)\n}\n\n/**\n * Removes alle listeners that trigger the given reactor function (compute)\n * This happens when a reactor is called, so that it can set new listeners\n * based on the current call (code path)\n */\nfunction clearListeners(compute) {\n    let connectedSignals = computeMap.get(compute)\n    if (connectedSignals) {\n        connectedSignals.forEach(property => {\n            property.forEach(s => {\n                let listeners = listenersMap.get(s)\n                if (listeners.has(property)) {\n                    listeners.get(property).delete(compute)\n                }\n            })\n        })\n    }\n}\n\n/**\n * The top most entry is the currently running update function, used\n * to automatically record signals used in an update function.\n */\nlet computeStack = []\n\n/**\n * Used for cycle detection: effectStack contains all running effect\n * functions. If the same function appears twice in this stack, there\n * is a recursive update call, which would cause an infinite loop.\n */\nconst effectStack = []\n\nconst effectMap = new WeakMap()\n/**\n * Used for cycle detection: signalStack contains all used signals. \n * If the same signal appears more than once, there is a cyclical \n * dependency between signals, which would cause an infinite loop.\n */\nconst signalStack = []\n\n/**\n * Runs the given function at once, and then whenever a signal changes that\n * is used by the given function (or at least signals used in the previous run).\n */\nexport function effect(fn) {\n    if (effectStack.findIndex(f => fn==f)!==-1) {\n        throw new Error('Recursive update() call', {cause:fn})\n    }\n    effectStack.push(fn)\n\n    let connectedSignal = signals.get(fn)\n    if (!connectedSignal) {\n        connectedSignal = signal({\n            current: null\n        })\n        signals.set(fn, connectedSignal)\n    }\n\n    // this is the function that is called automatically\n    // whenever a signal dependency changes\n    const computeEffect = function computeEffect() {\n        if (signalStack.findIndex(s => s==connectedSignal)!==-1) {\n            throw new Error('Cyclical dependency in update() call', { cause: fn})\n        }\n        // remove all dependencies (signals) from previous runs \n        clearListeners(computeEffect)\n        // record new dependencies on this run\n        computeStack.push(computeEffect)\n        // prevent recursion\n        signalStack.push(connectedSignal)\n        // call the actual update function\n        let result\n        try {\n            result = fn(computeEffect, computeStack, signalStack)\n        } finally {\n            // stop recording dependencies\n            computeStack.pop()\n            // stop the recursion prevention\n            signalStack.pop()\n            if (result instanceof Promise) {\n                result.then((result) => {\n                    connectedSignal.current = result\n                })\n            } else {\n                connectedSignal.current = result\n            }\n        }\n    }\n    computeEffect.fn = fn\n    effectMap.set(connectedSignal, computeEffect)\n\n    // run the computEffect immediately upon creation\n    computeEffect()\n    return connectedSignal\n}\n\n\nexport function destroy(connectedSignal) {\n    // find the computeEffect associated with this signal\n    const computeEffect = effectMap.get(connectedSignal)?.deref()\n    if (!computeEffect) {\n        return\n    }\n\n    // remove all listeners for this effect\n    clearListeners(computeEffect)\n\n    // remove all references to connectedSignal\n    let fn = computeEffect.fn\n    signals.remove(fn)\n\n    effectMap.delete(connectedSignal)\n\n    // if no other references to connectedSignal exist, it will be garbage collected\n}\n\n/**\n * Inside a batch() call, any changes to signals do not trigger effects\n * immediately. Instead, immediately after finishing the batch() call,\n * these effects will be called. Effects that are triggered by multiple\n * signals are called only once.\n * @param Function fn batch() calls this function immediately\n * @result mixed the result of the fn() function call\n */\nexport function batch(fn) {\n    batchMode++\n    let result\n    try {\n        result = fn()\n    } finally {\n        if (result instanceof Promise) {\n            result.then(() => {\n                batchMode--\n                if (!batchMode) {\n                    runBatchedListeners()\n                }\n            })\n        } else {\n            batchMode--\n            if (!batchMode) {\n                runBatchedListeners()\n            }\n        }\n    }\n    return result\n}\n\nfunction runBatchedListeners() {\n    let copyBatchedListeners = Array.from(batchedListeners)\n    batchedListeners = new Set()\n    const currentEffect = computeStack[computeStack.length-1]\n    for (let listener of copyBatchedListeners) {\n        if (listener!=currentEffect && listener?.needsUpdate) {\n            listener()\n        }\n        clearContext(listener)\n    }\n}\n\n/**\n * A throttledEffect is run immediately once. And then only once\n * per throttleTime (in ms).\n * @param Function fn the effect function to run whenever a signal changes\n * @param int throttleTime in ms\n * @returns signal with the result of the effect function fn\n */\nexport function throttledEffect(fn, throttleTime) {\n    if (effectStack.findIndex(f => fn==f)!==-1) {\n        throw new Error('Recursive update() call', {cause:fn})\n    }\n    effectStack.push(fn)\n\n    let connectedSignal = signals.get(fn)\n    if (!connectedSignal) {\n        connectedSignal = signal({\n            current: null\n        })\n        signals.set(fn, connectedSignal)\n    }\n\n    let throttled = false\n    let hasChange = true\n    // this is the function that is called automatically\n    // whenever a signal dependency changes\n    const computeEffect = function computeEffect() {\n        if (signalStack.findIndex(s => s==connectedSignal)!==-1) {\n            throw new Error('Cyclical dependency in update() call', { cause: fn})\n        }\n        if (throttled && throttled>Date.now()) {\n            hasChange = true\n            return\n        }\n        // remove all dependencies (signals) from previous runs \n        clearListeners(computeEffect)\n        // record new dependencies on this run\n        computeStack.push(computeEffect)\n        // prevent recursion\n        signalStack.push(connectedSignal)\n        // call the actual update function\n        let result\n        try {\n            result = fn(computeEffect, computeStack, signalStack)\n        } finally {\n            hasChange = false\n            // stop recording dependencies\n            computeStack.pop()\n            // stop the recursion prevention\n            signalStack.pop()\n            if (result instanceof Promise) {\n                result.then((result) => {\n                    connectedSignal.current = result\n                })\n            } else {\n                connectedSignal.current = result\n            }\n        }\n        throttled = Date.now()+throttleTime\n        globalThis.setTimeout(() => {\n            if (hasChange) {\n                computeEffect()\n            }\n        }, throttleTime)\n    }\n    // run the computEffect immediately upon creation\n    computeEffect()\n    return connectedSignal\n}\n\n// refactor: Class clock() with an effect() method\n// keep track of effects per clock, and add clock property to the effect function\n// on notifySet add clock.effects to clock.needsUpdate list\n// on clock.tick() (or clock.time++) run only the clock.needsUpdate effects \n// (first create a copy and reset clock.needsUpdate, then run effects)\nexport function clockEffect(fn, clock) {\n    let connectedSignal = signals.get(fn)\n    if (!connectedSignal) {\n        connectedSignal = signal({\n            current: null\n        })\n        signals.set(fn, connectedSignal)\n    }\n\n    let lastTick = -1 // clock.time should start at 0 or larger\n    let hasChanged = true // make sure the first run goes through\n    // this is the function that is called automatically\n    // whenever a signal dependency changes\n    const computeEffect = function computeEffect() {\n        if (lastTick < clock.time) {\n            if (hasChanged) {\n                // remove all dependencies (signals) from previous runs \n                clearListeners(computeEffect)\n                // record new dependencies on this run\n                computeStack.push(computeEffect)\n                // make sure the clock.time signal is a dependency\n                lastTick = clock.time\n                // call the actual update function\n                let result \n                try {\n                    result = fn(computeEffect, computeStack)\n                } finally {\n                    // stop recording dependencies\n                    computeStack.pop()\n                    if (result instanceof Promise) {\n                        result.then((result) => {\n                            connectedSignal.current = result\n                        })\n                    } else {\n                        connectedSignal.current = result\n                    }\n                    hasChanged = false\n                }\n            } else {\n                lastTick = clock.time\n            }\n        } else {\n            hasChanged = true\n        }\n    }\n    // run the computEffect immediately upon creation\n    computeEffect()\n    return connectedSignal\n}\n\nexport function untracked(fn) {\n    const remember = computeStack.slice()\n    computeStack = []\n    try {\n        return fn()\n    } finally {\n        computeStack = remember\n    }\n}", "import { throttledEffect } from './state.mjs'\n\nclass SimplyBind {\n    constructor(options) {\n        const defaultOptions = {\n            container: document.body,\n            attribute: 'data-bind',\n            transformers: [],\n            defaultTransformers: [defaultTransformer]\n        }\n        if (!options?.root) {\n            throw new Error('bind needs at least options.root set')\n        }\n        this.options = Object.assign({}, defaultOptions, options)\n\n        const attribute = this.options.attribute\n\n        // sets up the effect that updates the element if its\n        // data binding value changes\n        const render = (el) => {\n            throttledEffect(() => {\n                const context = {\n                    templates: el.querySelectorAll(':scope > template'),\n                    path: this.getBindingPath(el)\n                }\n                context.value = getValueByPath(this.options.root, context.path)\n                context.element = el\n                runTransformers(context)\n            }, 100)\n        }\n\n        // finds and runs applicable transformers\n        // creates a stack of transformers, calls the topmost\n        // each transformer can opt to call the next or not\n        // transformers should return the context object (possibly altered)\n        const runTransformers = (context) => {\n            let transformers = this.options.defaultTransformers || []\n            if (context.element.dataset.transform) {\n                context.element.dataset.transform.split(' ').filter(Boolean).forEach(t => {\n                    if (this.options.transformers[t]) {\n                        transformers.push(this.options.transformers[t])\n                    } else {\n                        console.warn('No transformer with name '+t+' configured', {cause:context.element})\n                    }\n                })\n            }\n            let next\n            for (let transformer of transformers) {\n                next = ((next, transformer) => {\n                    return (context) => {\n                        return transformer.call(this, context, next)\n                    }\n                })(next, transformer)\n            }\n            next(context)\n        }\n\n        // given a set of elements with data bind attribute\n        // this renders each of those elements\n        const applyBindings = (bindings) => {\n            for (let bindingEl of bindings) {\n                render(bindingEl)\n            }\n        }\n\n        // this handles the mutation observer changes\n        // if any element is added, and has a data bind attribute\n        // it applies that data binding\n        const updateBindings = (changes) => {\n            for (const change of changes) {\n                if (change.type==\"childList\" && change.addedNodes) {\n                    for (let node of change.addedNodes) {\n                        if (node instanceof HTMLElement) {\n                            let bindings = Array.from(node.querySelectorAll(`[${attribute}]`))\n                            if (node.matches(`[${attribute}]`)) {\n                                bindings.unshift(node)\n                            }\n                            if (bindings.length) {\n                                applyBindings(bindings)\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // this responds to elements getting added to the dom\n        // and if any have data bind attributes, it applies those bindings\n        const observer = new MutationObserver((changes) => {\n            updateBindings(changes)\n        })\n\n        observer.observe(options.container, {\n            subtree: true,\n            childList: true\n        })\n\n        // this finds elements with data binding attributes and applies those bindings\n        // must come after setting up the observer, or included templates\n        // won't trigger their own bindings\n        const bindings = this.options.container.querySelectorAll('['+this.options.attribute+']:not(template)')\n        if (bindings.length) {\n            applyBindings(bindings)\n        }\n\n    }\n\n    /**\n     * Finds the first matching template and creates a new DocumentFragment\n     * with the correct data bind attributes in it (prepends the current path)\n     */\n    applyTemplate(path, templates, list, index) {\n        let template = this.findTemplate(templates, list[index])\n        if (!template) {\n            let result = new DocumentFragment()\n            result.innerHTML = '<!-- no matching template -->'\n            return result\n        }\n        let clone = template.content.cloneNode(true)\n        if (!clone.children?.length) {\n            throw new Error('template must contain a single html element', { cause: template })\n        }\n        if (clone.children.length>1) {\n            throw new Error('template must contain a single root node', { cause: template })\n        }\n        const bindings = clone.querySelectorAll('['+this.options.attribute+']')\n        const attribute = this.options.attribute\n        for (let binding of bindings) {\n            const bind = binding.getAttribute(attribute)\n            if (bind.substring(0, '#root.'.length)=='#root.') {\n                binding.setAttribute(attribute, bind.substring('#root.'.length))\n            } else if (bind=='#value') {\n                binding.setAttribute(attribute, path+'.'+index)\n            } else {\n                binding.setAttribute(attribute, path+'.'+index+'.'+bind)\n            }\n        }\n        clone.children[0].setAttribute(attribute+'-key',index)\n        // keep track of the used template, so if that changes, the \n        // item can be updated\n        clone.children[0].$bindTemplate = template\n        return clone\n    }\n\n    getBindingPath(el) {\n        return el.getAttribute(this.options.attribute)\n    }\n\n    /**\n     * Finds the first template from an array of templates that\n     * matches the given value. \n     */\n    findTemplate(templates, value) {\n        const templateMatches = t => {\n            let path = this.getBindingPath(t)\n            if (!path) {\n                return t\n            }\n            let currentItem\n            if (path.substr(0,6)=='#root.') {\n                currentItem = getValueByPath(this.options.root, path)\n            } else {\n                currentItem = getValueByPath(value, path)\n            }\n            const strItem = ''+currentItem\n            let matches = t.getAttribute(this.options.attribute+'-matches')\n            if (matches) {\n                if (matches==='#empty' && !currentItem) {\n                    return t\n                } else if (matches==='#notempty' && currentItem) {\n                    return t\n                }\n                if (strItem.match(matches)) {\n                    return t\n                }\n            }\n            if (!matches) {\n                if (currentItem) {\n                    return t\n                }\n            }\n        };\n        let template = Array.from(templates).find(templateMatches)\n        let rel = template?.getAttribute('rel')\n        if (rel) {\n            let replacement = document.querySelector('template#'+rel)\n            if (!replacement) {\n                throw new Error('Could not find template with id '+rel)\n            }\n            template = replacement\n        }\n        return template\n    }\n\n}\n\n/**\n * Returns a new instance of SimplyBind. This is the normal start\n * of a data bind flow\n */\nexport function bind(options)\n{\n    return new SimplyBind(options)\n}\n\n/**\n * Returns true if a matches b, either by having the\n * same string value, or matching string #empty against a falsy value\n */\nexport function matchValue(a,b) {\n    if (a=='#empty' && !b) {\n        return true\n    }\n    if (b=='#empty' && !a) {\n        return true\n    }\n    if (''+a == ''+b) {\n        return true\n    }\n    return false\n}\n\n/**\n * Returns the value by walking the given path\n * as a json pointer, starting at root\n * if you have a property with a '.' in its name\n * urlencode the '.', e.g: %46\n */\nexport function getValueByPath(root, path)\n{\n    let parts = path.split('.');\n    let curr = root;\n    let part, prevPart;\n    while (parts.length && curr) {\n        part = parts.shift()\n        if (part=='#key') {\n            return prevPart\n        } else if (part=='#value') {\n            return curr\n        } else if (part=='#root') {\n            curr = root\n        } else {\n            part = decodeURIComponent(part)\n            curr = curr[part];\n            prevPart = part\n        }\n    }\n    return curr\n}\n\n/**\n * Default transformer for data binding\n * Will be used unless overriden in the SimplyBind options parameter\n */\nexport function defaultTransformer(context) {\n    const el = context.element\n    const templates = context.templates\n    const templatesCount = templates.length \n    const path = context.path\n    const value = context.value\n    const attribute = this.options.attribute\n    if (Array.isArray(value) && templates?.length) {\n        transformArrayByTemplates.call(this, context)\n    } else if (value && typeof value == 'object' && templates?.length) {\n        transformObjectByTemplates.call(this, context)\n    } else if (el.tagName=='INPUT') {\n        transformInput.call(this, context)\n    } else if (el.tagName=='BUTTON') {\n        transformButton.call(this, context)\n    } else if (el.tagName=='SELECT') {\n        transformSelect.call(this, context)\n    } else if (el.tagName=='A') {\n        transformAnchor.call(this, context)\n    } else {\n        transformElement.call(this, context)\n    }\n    return context\n}\n\n/**\n * Renders an array value by applying templates for each entry\n * Replaces or removes existing DOM children if needed\n * Reuses (doesn't touch) DOM children if template doesn't change\n */\nexport function transformArrayByTemplates(context) {\n    const el             = context.element\n    const templates      = context.templates\n    const templatesCount = templates.length \n    const path           = context.path\n    const value          = context.value\n    const attribute      = this.options.attribute\n\n    let items = el.querySelectorAll(':scope > ['+attribute+'-key]')\n    // do single merge strategy for now, in future calculate optimal merge strategy from a number\n    // now just do a delete if a key <= last key, insert if a key >= last key\n    let lastKey = 0\n    let skipped = 0\n    for (let item of items) {\n        let currentKey = parseInt(item.getAttribute(attribute+'-key'))\n        if (currentKey>lastKey) {\n            // insert before\n            el.insertBefore(this.applyTemplate(path, templates, value, lastKey), item)\n        } else if (currentKey<lastKey) {\n            // remove this\n            item.remove()\n        } else {\n            // check that all data-bind params start with current json path or a '#', otherwise replaceChild\n            let bindings = Array.from(item.querySelectorAll(`[${attribute}]`))\n            if (item.matches(`[${attribute}]`)) {\n                bindings.unshift(item)\n            }\n            let needsReplacement = bindings.find(b => {\n                let databind = b.getAttribute(attribute)\n                return (databind.substr(0,5)!=='#root' \n                    && databind.substr(0, path.length)!==path)\n            })\n            if (!needsReplacement) {\n                if (item.$bindTemplate) {\n                    let newTemplate = this.findTemplate(templates, value[lastKey])\n                    if (newTemplate != item.$bindTemplate){\n                        needsReplacement = true\n                        if (!newTemplate) {\n                            skipped++\n                        }\n                    }\n                }\n            }\n            if (needsReplacement) {\n                el.replaceChild(this.applyTemplate(path, templates, value, lastKey), item)\n            }\n        }\n        lastKey++\n        if (lastKey>=value.length) {\n            break\n        }\n    }\n    items = el.querySelectorAll(':scope > ['+attribute+'-key]')\n    let length = items.length + skipped\n    if (length > value.length) {\n        while (length > value.length) {\n            let child = el.querySelectorAll(':scope > :not(template)')?.[length-1]\n            child?.remove()\n            length--\n        }\n    } else if (length < value.length ) {\n        while (length < value.length) {\n            el.appendChild(this.applyTemplate(path, templates, value, length))\n            length++\n        }\n    }\n}\n\n/**\n * Renders an object value by applying templates for each entry (Object.entries)\n * Replaces or removes existing DOM children if needed\n * Reuses (doesn't touch) DOM children if template doesn't change\n */\nexport function transformObjectByTemplates(context) {\n    const el             = context.element\n    const templates      = context.templates\n    const templatesCount = templates.length \n    const path           = context.path\n    const value          = context.value\n    const attribute      = this.options.attribute\n    \n    let list    = Object.entries(value)\n    let items   = el.querySelectorAll(':scope > ['+attribute+'-key]')\n    let current = 0\n    let skipped = 0\n    for (let item of items) {\n        if (current>=list.length) {\n            break\n        }\n        let key = list[current][0]\n        current++\n        let keypath = path+'.'+key\n        // check that all data-bind params start with current json path or a '#', otherwise replaceChild\n        let needsReplacement\n        const databind = item.getAttribute(attribute)\n        if (databind && databind.substr(0, keypath.length)!=keypath) {\n            needsReplacement=true\n        } else {\n            let bindings = Array.from(item.querySelectorAll(`[${attribute}]`))\n            needsReplacement = bindings.find(b => {\n                const db = b.getAttribute(attribute)\n                return (db.substr(0,5)!=='#root' && db.substr(0, keypath.length)!==keypath)\n            })\n            if (!needsReplacement) {\n                if (item.$bindTemplate) {\n                    let newTemplate = this.findTemplate(templates, value[key])\n                    if (newTemplate != item.$bindTemplate){\n                        needsReplacement = true\n                        if (!newTemplate) {\n                            skipped++\n                        }\n                    }\n                }\n            }\n        }\n        if (needsReplacement) {\n            let clone = this.applyTemplate(path, templates, value, key)\n            el.replaceChild(clone, item)\n        }\n    }\n    items  = el.querySelectorAll(':scope > ['+attribute+'-key]')\n    let length = items.length + skipped\n    if (length>list.length) {\n        while (length>list.length) {\n            let child = el.querySelectorAll(':scope > :not(template)')?.[length-1]\n            child?.remove()\n            length--\n        }\n    } else if (length < list.length) {\n        while (length < list.length) {\n            let key = list[length][0]\n            el.appendChild(this.applyTemplate(path, templates, value, key))\n            length++\n        }\n    } \n}\n\n/**\n * transforms a single input type\n * for radio/checkbox inputs it only sets the checked attribute to true/false\n * if the value attribute matches the current value\n * for other inputs the value attribute is updated\n * FIXME: handle radio/checkboxes in separate transformer\n */\nexport function transformInput(context) {\n    const el    = context.element\n    const value = context.value\n\n    if (el.type=='checkbox' || el.type=='radio') {\n        if (matchValue(el.value, value)) {\n            el.checked = true\n        } else {\n            el.checked = false\n        }\n    } else if (!matchValue(el.value, value)) {\n        el.value = ''+value\n    }\n}\n\n/**\n * Sets the value of the button, doesn't touch the innerHTML\n */\nexport function transformButton(context) {\n    const el    = context.element\n    const value = context.value\n\n    if (!matchValue(el.value,value)) {\n        el.value = ''+value\n    }\n}\n\n/**\n * Sets the selected attribute of select options\n */\nexport function transformSelect(context) {\n    const el    = context.element\n    const value = context.value\n\n    if (el.multiple) {\n        if (Array.isArray(value)) {\n            for (let option of el.options) {\n                if (value.indexOf(option.value)===false) {\n                    option.selected = false\n                } else {\n                    option.selected = true\n                }\n            }\n        }\n    } else {\n        let option = el.options.find(o => matchValue(o.value,value))\n        if (option) {\n            option.selected = true\n        }\n    }\n}\n\n/**\n * Sets the innerHTML and href attribute of an anchor\n * TODO: support target, title, etc. attributes\n */\nexport function transformAnchor(context) {\n    const el    = context.element\n    const value = context.value\n\n    if (value?.innerHTML && !matchValue(el.innerHTML, value.innerHTML)) {\n        el.innerHTML = ''+value.innerHTML\n    }\n    if (value?.href && !matchValue(el.href,value.href)) {\n        el.href = ''+value.href\n    }    \n}\n\n/**\n * sets the innerHTML of any HTML element\n */\nexport function transformElement(context) {\n    const el    = context.element\n    const value = context.value\n\n    if (!matchValue(el.innerHTML, value)) {\n        el.innerHTML = ''+value\n    }\n}", "import { routes } from './route.mjs'\nimport { commands } from './command.mjs'\nimport { actions } from './action.mjs'\nimport { keys } from './key.mjs'\nimport { signal } from './state.mjs'\nimport { bind } from './bind.mjs'\n\nclass SimplyApp {\n\tconstructor(options={}) {\n\t\tthis.container = options.container || document.body\n\t\tif (options.state) {\n\t\t\tthis.state = signal(options.state)\n\t\t}\n\t\tif (options.commands) {\n\t\t\tthis.commands = commands({ app: this, container: this.container, commands: options.commands})\n\t\t}\n\t\tif (options.keys) {\n\t\t\tthis.keys = keys({ app: this, keys: options.keys })\n\t\t}\n\t\tif (options.routes) {\n\t\t\tthis.routes = routes({ app: this, routes: options.routes})\n\t\t}\n\t\tif (options.actions) {\n\t\t\tthis.actions = actions({app: this, actions: options.actions})\n\t\t}\n\t\tbind({ container: this.container, state: this.state })\n\t}\n}\n\nexport function app(options={}) {\n\treturn new SimplyApp(options)\n}"],
  "mappings": "MAAO,SAASA,EAAOC,EAAS,CAC/B,OAAO,IAAIC,EAAYD,CAAO,CAC/B,CAEA,IAAMC,EAAN,KAAkB,CACjB,YAAYD,EAAQ,CAAC,EAAG,CACvB,KAAK,KAAOA,EAAQ,MAAQ,IACtB,KAAK,IAAMA,EAAQ,IACzB,KAAK,MAAM,EACPA,EAAQ,QACX,KAAK,KAAKA,EAAQ,MAAM,CAE1B,CAEA,KAAKD,EAAQ,CACZG,EAAYH,EAAQ,KAAK,SAAS,CACnC,CAEA,OAAQ,CACP,KAAK,UAAY,CAAC,EAClB,KAAK,UAAY,CAChB,MAAO,CAAC,EACR,KAAM,CAAC,EACP,OAAQ,CAAC,CACV,CACD,CAEA,MAAMI,EAAMH,EAAS,CACpB,IAAII,EAAO,CACD,KAAAD,EACA,QAAAH,CACJ,EACAI,EAAO,KAAK,aAAa,QAAQA,CAAI,EACrCD,EAAOC,EAAK,KAAOA,EAAK,KAAOD,EAE/B,IAAIE,EACJ,GAAI,CAACF,EACD,OAAI,KAAK,MAAM,SAAS,SAAS,SAAS,SAAS,SAAS,IAAI,EACrD,GAEA,KAAK,MAAM,SAAS,SAAS,QAAQ,EAGpDA,EAAOG,EAAQH,CAAI,EACnB,QAAUI,KAAS,KAAK,UAEpB,GADAF,EAAUE,EAAM,MAAM,KAAKJ,CAAI,EAC3BE,GAAWA,EAAQ,OAAQ,CAC3B,IAAIG,EAAS,CAAC,EACd,OAAAD,EAAM,OAAO,QAAQ,CAACE,EAAKC,IAAM,CACzBD,GAAK,MACLA,EAAM,aAEVD,EAAOC,CAAG,EAAIJ,EAAQK,EAAE,CAAC,CAC7B,CAAC,EACD,OAAO,OAAOF,EAAQR,CAAO,EAC7BI,EAAK,MAAQG,EACbH,EAAK,OAASI,EACdJ,EAAO,KAAK,aAAa,OAAQA,CAAI,EACrCI,EAASJ,EAAK,OAASA,EAAK,OAASI,EACrCJ,EAAK,OAASG,EAAM,OAAO,KAAKA,EAAOC,CAAM,EAC7C,KAAK,aAAa,SAAUJ,CAAI,EACzBA,EAAK,MAChB,CAEJ,OAAID,GAAQA,EAAKA,EAAK,OAAO,CAAC,GAAG,IACzB,KAAK,MAAMA,EAAK,IAAKH,CAAO,EAE7B,EACd,CAEA,aAAaW,EAAQH,EAAQ,CACtB,GAAK,OAAO,KAAK,KAAK,UAAUG,CAAM,CAAC,EAGvC,cAAO,KAAK,KAAK,UAAUA,CAAM,CAAC,EAAE,QAASJ,GAAU,CACnD,IAAIK,EAAUC,EAAmBN,CAAK,EACtC,GAAIK,EAAQ,KAAKJ,EAAO,IAAI,EAAG,CAC3B,IAAIM,EACJ,QAASC,KAAY,KAAK,UAAUJ,CAAM,EAAEJ,CAAK,EAC7CO,EAASC,EAAS,KAAK,KAAK,IAAKP,CAAM,EACnCM,IACAN,EAASM,EAGrB,CACJ,CAAC,EACMN,CACX,CAEA,cAAe,CACX,WAAW,iBAAiB,WAAY,IAAM,CACtC,KAAK,MAAMF,EAAQ,SAAS,SAAS,SAAW,SAAS,SAAS,KAAM,KAAK,IAAI,CAAC,IAAM,IACxF,KAAK,MAAMA,EAAQ,SAAS,SAAS,SAAU,KAAK,IAAI,CAAC,CAEjE,CAAC,EACD,WAAW,SAAS,iBAAiB,QAAUU,GAAQ,CACtD,GAAI,CAAAA,EAAI,SAGJA,EAAI,OAAS,EAIjB,SADIC,EAAOD,EAAI,OACRC,GAAQA,EAAK,SAAS,KACzBA,EAAOA,EAAK,cAEhB,GAAIA,GACGA,EAAK,UACLA,EAAK,UAAU,WAAW,SAAS,UACnC,CAACA,EAAK,MACN,CAACA,EAAK,QAAQ,cACnB,CACE,IAAId,EAAOG,EAAQW,EAAK,SAASA,EAAK,KAAM,KAAK,IAAI,EAIrD,GAHM,KAAK,IAAId,CAAI,IACfA,EAAOG,EAAQW,EAAK,SAAU,KAAK,IAAI,GAEtC,KAAK,IAAId,CAAI,EAAI,CAClB,IAAIK,EAAS,KAAK,aAAa,OAAQ,CAAE,KAAML,CAAI,CAAC,EACpD,OAAIK,EAAO,MACP,KAAK,KAAKA,EAAO,IAAI,EAEzBQ,EAAI,eAAe,EACZ,EACX,CACJ,EACJ,CAAC,CACF,CAEA,KAAKb,EAAM,CACP,eAAQ,UAAU,CAAC,EAAE,GAAGe,EAAOf,CAAI,CAAC,EAC7B,KAAK,MAAMA,CAAI,CAC1B,CAEA,IAAIA,EAAM,CACTA,EAAOG,EAAQH,EAAM,KAAK,IAAI,EAC9B,QAASI,KAAS,KAAK,UAAW,CAC3B,IAAIF,EAAUE,EAAM,MAAM,KAAKJ,CAAI,EACnC,GAAIE,GAAWA,EAAQ,OACnB,MAAO,EAEf,CACA,MAAO,EACX,CAEA,YAAYM,EAAQJ,EAAOQ,EAAU,CACjC,GAAI,CAAC,OAAO,QAAQ,OAAO,QAAQ,EAAE,QAAQJ,CAAM,GAAG,GAClD,MAAM,IAAI,MAAM,kBAAkBA,CAAM,EAEvC,KAAK,UAAUA,CAAM,EAAEJ,CAAK,IAC7B,KAAK,UAAUI,CAAM,EAAEJ,CAAK,EAAI,CAAC,GAErC,KAAK,UAAUI,CAAM,EAAEJ,CAAK,EAAE,KAAKQ,CAAQ,CAC/C,CAEA,eAAeJ,EAAQJ,EAAOQ,EAAU,CACpC,GAAI,CAAC,QAAQ,OAAO,QAAQ,EAAE,QAAQJ,CAAM,GAAG,GAC3C,MAAM,IAAI,MAAM,kBAAkBA,CAAM,EAEvC,KAAK,UAAUA,CAAM,EAAEJ,CAAK,IAGjC,KAAK,UAAUI,CAAM,EAAEJ,CAAK,EAAI,KAAK,UAAUI,CAAM,EAAEJ,CAAK,EAAE,OAAQY,GAC3DA,GAAYJ,CACtB,EACL,CAEA,KAAKf,EAAS,CACTA,EAAQ,OACX,KAAK,KAAOA,EAAQ,KAEtB,CACJ,EAEA,SAASM,EAAQH,EAAMiB,EAAK,IAAK,CAC7B,OAAIjB,EAAK,UAAU,EAAEiB,EAAK,MAAM,GAAGA,GAE7BA,EAAKA,EAAK,OAAO,CAAC,GAAG,KAChBjB,EAAK,QAASiB,EAAK,OAAO,GAC1BjB,GAAQiB,EAAK,UAAU,EAAEjB,EAAK,MAAM,KAG3CA,EAAOA,EAAK,UAAUiB,EAAK,MAAM,GAEjCjB,EAAK,CAAC,GAAG,KAAOA,EAAK,CAAC,GAAG,MACzBA,EAAO,IAAIA,GAERA,CACX,CAEA,SAASe,EAAOf,EAAMiB,EAAM,CACxB,OAAAjB,EAAOG,EAAQH,EAAMiB,CAAI,EACrBA,EAAKA,EAAK,OAAO,CAAC,IAAI,KAAOjB,EAAK,CAAC,IAAI,MACvCA,EAAOA,EAAK,UAAU,CAAC,GAEpBiB,EAAOjB,CAClB,CAEA,SAASU,EAAmBN,EAAO,CAC/B,OAAO,IAAI,OAAO,IAAIA,EAAM,QAAQ,QAAS,SAAS,EAAE,QAAQ,MAAO,MAAM,CAAC,CAClF,CAEA,SAASL,EAAYH,EAAQ,CACzB,IAAIsB,EAAY,CAAC,EACXC,EAAQ,OAAO,KAAKvB,CAAM,EAC1BwB,EAAc,aACpB,QAASpB,KAAQmB,EAAO,CACpB,IAAIjB,EAAU,CAAC,EACXG,EAAU,CAAC,EACf,GACIH,EAAUkB,EAAY,KAAKpB,CAAI,EAC3BE,GACAG,EAAO,KAAKH,EAAQ,CAAC,CAAC,QAEtBA,GACRgB,EAAU,KAAK,CACX,MAAQR,EAAmBV,CAAI,EAC/B,OAAQK,EACR,OAAQT,EAAOI,CAAI,CACvB,CAAC,CACL,CACA,OAAOkB,CACX,CC7NA,IAAMG,EAAN,KAAqB,CACpB,YAAYC,EAAQ,CAAC,EAAG,CAClBA,EAAQ,MACZA,EAAQ,IAAM,CAAC,GAEXA,EAAQ,IAAI,YAChBA,EAAQ,IAAI,UAAY,SAAS,MAElC,KAAK,IAAMA,EAAQ,IACnB,KAAK,SAAWA,EAAQ,UAAYC,EACpC,KAAK,SAAWD,EAAQ,UAAY,CAAC,EAErC,IAAME,EAAkBC,GAAQ,CAC/B,IAAMC,EAAUC,EAAWF,EAAK,KAAK,QAAQ,EAC7C,GAAKC,EAGL,IAAI,CAAC,KAAK,SAASA,EAAQ,IAAI,EAAG,CACrB,QAAQ,MAAM,qCAAqCA,EAAQ,KAAMA,EAAQ,MAAM,EAC/E,MACb,CACA,KAAK,SAASA,EAAQ,IAAI,EAAE,KAAK,KAAK,IAAKA,EAAQ,OAAQA,EAAQ,KAAK,EACzE,EAEM,SAASE,EAAKC,EAAI,CACd,OAAQJ,IACJI,EAAGJ,CAAG,EACNA,EAAI,eAAe,EACnBA,EAAI,gBAAgB,EACb,GAEf,CAEA,KAAK,IAAI,UAAU,iBAAiB,QAASG,EAAKJ,CAAc,CAAC,EACjE,KAAK,IAAI,UAAU,iBAAiB,SAAUI,EAAKJ,CAAc,CAAC,EAClE,KAAK,IAAI,UAAU,iBAAiB,SAAUA,CAAc,EAC5D,KAAK,IAAI,UAAU,iBAAiB,QAASA,CAAc,CAClE,CACD,EAEO,SAASM,EAASR,EAAQ,CAAC,EAAG,CACpC,OAAO,IAAID,EAAeC,CAAO,CAClC,CAEA,SAASK,EAAWF,EAAKM,EAAU,CAC/B,IAAIC,EAAKP,EAAI,OAAO,QAAQ,uBAAuB,EACnD,GAAIO,GACA,QAASC,EAAEF,EAAS,OAAO,EAAGE,GAAG,EAAGA,IAChC,GAAID,EAAG,QAAQD,EAASE,CAAC,EAAE,KAAK,GACxBF,EAASE,CAAC,EAAE,MAAMD,EAAIP,CAAG,EACzB,MAAO,CACH,KAAQO,EAAG,QAAQ,cACnB,OAAQA,EACR,MAAQD,EAASE,CAAC,EAAE,IAAID,CAAE,CAC9B,EAKhB,OAAO,IACX,CAEA,IAAMT,EAAkB,CACpB,CACI,MAAO,wBACP,IAAK,SAASS,EAAI,CACd,GAAIA,EAAG,UAAU,UAAYA,EAAG,SAAU,CACtC,IAAIE,EAAS,CAAC,EACd,QAASC,KAAUH,EAAG,QACdG,EAAO,UACPD,EAAO,KAAKC,EAAO,KAAK,EAGhC,OAAOD,CACX,CACA,OAAOF,EAAG,QAAQ,aAAeA,EAAG,KACxC,EACA,MAAO,SAASA,EAAIP,EAAK,CACrB,OAAOA,EAAI,MAAM,UAAaO,EAAG,QAAQ,iBAAmBP,EAAI,MAAM,OAC1E,CACJ,EACA,CACI,MAAO,WACP,IAAK,SAASO,EAAI,CACd,OAAOA,EAAG,QAAQ,aAAeA,EAAG,MAAQA,EAAG,KACnD,EACA,MAAO,SAASA,EAAGP,EAAK,CACpB,OAAOA,EAAI,MAAM,SAAWA,EAAI,SAAS,IAASA,EAAI,QAAQ,CAClE,CACJ,EACA,CACI,MAAO,OACP,IAAK,SAASO,EAAI,CACd,IAAII,EAAO,CAAC,EACZ,QAASC,KAAS,MAAM,KAAKL,EAAG,QAAQ,EAAG,CACvC,GAAIK,EAAM,SAAS,UACXA,EAAM,MAAM,YAAcA,EAAM,MAAM,UAEtC,CAACA,EAAM,QACP,OAGJD,EAAKC,EAAM,IAAI,GAAK,CAAC,MAAM,QAAQD,EAAKC,EAAM,IAAI,CAAC,IACnDD,EAAKC,EAAM,IAAI,EAAI,CAACD,EAAKC,EAAM,IAAI,CAAC,GAEpC,MAAM,QAAQD,EAAKC,EAAM,IAAI,CAAC,EAC9BD,EAAKC,EAAM,IAAI,EAAE,KAAKA,EAAM,KAAK,EAEjCD,EAAKC,EAAM,IAAI,EAAIA,EAAM,KAEjC,CACA,OAAOD,CACX,EACA,MAAO,SAASJ,EAAGP,EAAK,CACpB,OAAOA,EAAI,MAAM,QACrB,CACJ,EACA,CACC,MAAO,IACJ,IAAK,SAASO,EAAI,CACd,OAAOA,EAAG,QAAQ,WACtB,EACA,MAAO,SAASA,EAAIP,EAAK,CACrB,OAAOA,EAAI,MAAM,SAAWA,EAAI,SAAS,IAASA,EAAI,QAAQ,CAClE,CACJ,CACJ,EC9HA,IAAMa,EAAN,KAAoB,CACnB,YAAYC,EAAS,CACd,KAAK,IAAMA,EAAQ,IAEzB,IAAMC,EAAgB,CACrB,IAAK,CAACC,EAAQC,IACND,EAAOC,CAAQ,EAAE,KAAK,KAAK,GAAG,CAEvC,EAEA,KAAK,QAAU,IAAI,MAAM,CAAC,EAAGF,CAAa,EAC1C,OAAO,OAAO,KAAK,QAASD,EAAQ,OAAO,CAC5C,CACD,EAEO,SAASI,EAAQJ,EAAS,CAChC,OAAO,IAAID,EAAcC,CAAO,CACjC,CCjBA,IAAMK,EAAN,KAAiB,CAChB,YAAYC,EAAU,CAAC,EAAI,CACrBA,EAAQ,MACZA,EAAQ,IAAM,CAAC,GAEXA,EAAQ,IAAI,YAChBA,EAAQ,IAAI,UAAY,SAAS,MAElC,KAAK,IAAMA,EAAQ,IACnB,KAAK,IAAI,UAAU,iBAAiB,UAAWC,EAAW,KAAK,IAAI,CAAC,CACrE,CACD,EAEO,SAASC,EAAKF,EAAQ,CAAC,EAAG,CAChC,OAAO,IAAID,EAAWC,CAAO,CAC9B,CAEA,SAASC,EAAWC,EAAM,CACzB,OAAQ,GAAM,CAOb,GANI,EAAE,aAAe,EAAE,UAAY,KAG/B,EAAE,kBAGF,CAAC,EAAE,OACH,OAGJ,IAAIC,EAAmB,UACnB,EAAE,OAAO,QAAQ,wBAAwB,IACzCA,EAAmB,EAAE,OAAO,QAAQ,wBAAwB,EAAE,QAAQ,gBAE1E,IAAIC,EAAM,GAeV,GAdI,EAAE,SAAW,EAAE,SAAS,KACxBA,GAAK,YAEL,EAAE,SAAW,EAAE,SAAS,MACxBA,GAAK,SAEL,EAAE,QAAU,EAAE,SAAS,KACvBA,GAAK,QAEL,EAAE,UAAY,EAAE,SAAS,KACzBA,GAAK,UAETA,GAAK,EAAE,IAEHF,EAAKC,CAAgB,GAAKD,EAAKC,CAAgB,EAAEC,CAAG,EAAG,CACvD,IAAIC,EAAWH,EAAKC,CAAgB,EACpCE,EAAS,IAAMH,EAAK,IACpBG,EAASD,CAAG,EAAE,KAAKF,EAAK,IAAI,CAAC,CACjC,CACD,CACD,CCtDA,IAAMI,EAAS,OAAO,QAAQ,EACxBC,EAAU,OAAO,SAAS,EAE1BC,GAAgB,CAClB,IAAK,CAACC,EAAQC,EAAUC,IAAa,CACjC,GAAID,IAAWJ,EACX,OAAOG,EAEX,IAAMG,EAAQH,IAASC,CAAQ,EAE/B,OADAG,EAAUF,EAAUD,CAAQ,EACxB,OAAOE,GAAU,WACb,MAAM,QAAQH,CAAM,EACb,IAAIK,IAAS,CAChB,IAAIC,EAAIN,EAAO,OAIXO,EAASJ,EAAM,MAAMD,EAAUG,CAAI,EACvC,OAAIC,GAAKN,EAAO,QACZQ,EAAUN,EAAWO,EAAY,SAAU,CAAE,IAAKH,EAAG,IAAKN,EAAO,MAAO,CAAC,CAAE,EAExEO,CACX,EACOP,aAAkB,KAAOA,aAAkB,IAC3C,IAAIK,IAAS,CAIhB,IAAI,EAAIL,EAAO,KACXO,EAASJ,EAAM,MAAMH,EAAQK,CAAI,EACrC,OAAI,GAAKL,EAAO,MACZQ,EAAUN,EAAUO,EAAa,OAAQ,CAAE,IAAK,EAAG,IAAKT,EAAO,IAAK,CAAC,CAAE,EAMvE,CAAC,MAAM,MAAM,QAAQ,QAAQ,EAAE,SAASC,CAAQ,GAChDO,EAAUN,EAAUO,EAAa,CAAE,QAAS,CAAC,EAAG,QAAS,CAAC,EAAG,IAAK,CAAC,EAAG,KAAM,CAAC,EAAG,OAAQ,CAAC,EAAG,CAAC,OAAO,QAAQ,EAAG,CAAC,CAAE,CAAE,CAAE,EAEnHF,CACX,EAGOJ,EAAM,KAAKD,CAAQ,EAG9BC,GAAS,OAAOA,GAAS,SAElBO,EAAOP,CAAK,EAEhBA,CACX,EACA,IAAK,CAACH,EAAQC,EAAUE,EAAOD,IAAa,CACxCC,EAAQA,IAAQN,CAAM,GAAKM,EAC3B,IAAIQ,EAAUX,EAAOC,CAAQ,EAC7B,OAAIU,IAAUR,IACVH,EAAOC,CAAQ,EAAIE,EACnBK,EAAUN,EAAUO,EAAYR,EAAU,CAAE,IAAKU,EAAS,IAAKR,CAAM,CAAE,CAAE,GAEzE,OAAOQ,EAAY,KACnBH,EAAUN,EAAUO,EAAYX,EAAS,CAAC,CAAC,CAAC,EAEzC,EACX,EACA,IAAK,CAACE,EAAQC,IAAa,CACvB,IAAIC,EAAWU,EAAQ,IAAIZ,CAAM,EACjC,OAAIE,GACAE,EAAUF,EAAUD,CAAQ,EAEzB,OAAO,OAAOD,EAAQC,CAAQ,CACzC,EACA,eAAgB,CAACD,EAAQC,IAAa,CAClC,GAAI,OAAOD,EAAOC,CAAQ,EAAM,IAAa,CACzC,IAAIU,EAAUX,EAAOC,CAAQ,EAC7B,OAAOD,EAAOC,CAAQ,EACtB,IAAIC,EAAWU,EAAQ,IAAIZ,CAAM,EACjCQ,EAAUN,EAAUO,EAAYR,EAAS,CAAE,OAAQ,GAAM,IAAKU,CAAQ,CAAC,CAAC,CAC5E,CACA,MAAO,EACX,EACA,eAAgB,CAACX,EAAQC,EAAUY,IAAe,CAC9C,GAAI,OAAOb,EAAOC,CAAQ,EAAM,IAAa,CACzC,IAAIC,EAAWU,EAAQ,IAAIZ,CAAM,EACjCQ,EAAUN,EAAUO,EAAYX,EAAS,CAAC,CAAC,CAAC,CAChD,CACA,OAAO,OAAO,eAAeE,EAAQC,EAAUY,CAAU,CAC7D,EACA,QAAUb,GAAW,CACjB,IAAIE,EAAWU,EAAQ,IAAIZ,CAAM,EACjC,OAAAI,EAAUF,EAAUJ,CAAO,EACpB,QAAQ,QAAQE,CAAM,CACjC,CAEJ,EAQMY,EAAU,IAAI,QAMb,SAASF,EAAOI,EAAG,CACtB,OAAKF,EAAQ,IAAIE,CAAC,GACdF,EAAQ,IAAIE,EAAG,IAAI,MAAMA,EAAGf,EAAa,CAAC,EAEvCa,EAAQ,IAAIE,CAAC,CACxB,CAEA,IAAIC,EAAmB,IAAI,IACvBC,GAAY,EAMhB,SAASR,EAAUS,EAAMC,EAAQ,CAAC,EAAG,CACjC,IAAIC,EAAY,CAAC,EAWjB,GAVAD,EAAQ,QAAQ,CAACE,EAAQnB,IAAa,CAClC,IAAIoB,EAAgBC,GAAaL,EAAMhB,CAAQ,EAC/C,GAAIoB,GAAe,OAAQ,CACvB,QAASE,KAAYF,EACjBG,GAAWD,EAAUd,EAAYR,EAASmB,CAAM,CAAC,EAErDD,EAAYA,EAAU,OAAOE,CAAa,CAC9C,CACJ,CAAC,EACDF,EAAY,IAAI,IAAIA,EAAU,OAAO,OAAO,CAAC,EACzCA,EACA,GAAIH,GACAD,EAAmBA,EAAiB,MAAMI,CAAS,MAChD,CACH,IAAMM,EAAgBC,EAAaA,EAAa,OAAO,CAAC,EACxD,QAASH,KAAY,MAAM,KAAKJ,CAAS,EACjCI,GAAUE,GAAiBF,GAAU,aACrCA,EAAS,EAEbI,GAAaJ,CAAQ,CAE7B,CAER,CAEA,SAASd,EAAYR,EAAUmB,EAAQ,CACnC,IAAIF,EAAU,IAAI,IAClB,GAAI,OAAOjB,GAAa,SACpB,QAAS2B,KAAQ3B,EACbiB,EAAQ,IAAIU,EAAM3B,EAAS2B,CAAI,CAAC,OAGpCV,EAAQ,IAAIjB,EAAUmB,CAAM,EAEhC,OAAOF,CACX,CAEA,SAASM,GAAWD,EAAUL,EAAS,CAC9BK,EAAS,QAGVL,EAAQ,QAAQ,CAACE,EAAOnB,IAAY,CAChCsB,EAAS,QAAQ,IAAItB,EAAUmB,CAAM,CACzC,CAAC,EAJDG,EAAS,QAAUL,EAMvBK,EAAS,YAAc,EAC3B,CAEA,SAASI,GAAaJ,EAAU,CAC5B,OAAOA,EAAS,QAChB,OAAOA,EAAS,WACpB,CAQA,SAASnB,EAAUa,EAAMhB,EAAU,CAC/B,IAAI4B,EAAiBH,EAAaA,EAAa,OAAO,CAAC,EACnDG,GAEAC,GAAab,EAAMhB,EAAU4B,CAAc,CAEnD,CAMA,IAAME,EAAe,IAAI,QAMnBC,EAAa,IAAI,QAKvB,SAASV,GAAaL,EAAMhB,EAAU,CAClC,IAAIkB,EAAYY,EAAa,IAAId,CAAI,EACrC,OAAOE,EAAY,MAAM,KAAKA,EAAU,IAAIlB,CAAQ,GAAK,CAAC,CAAC,EAAI,CAAC,CACpE,CAMA,SAAS6B,GAAab,EAAMhB,EAAUgC,EAAS,CACtCF,EAAa,IAAId,CAAI,GACtBc,EAAa,IAAId,EAAM,IAAI,GAAK,EAEpC,IAAIE,EAAYY,EAAa,IAAId,CAAI,EAChCE,EAAU,IAAIlB,CAAQ,GACvBkB,EAAU,IAAIlB,EAAU,IAAI,GAAK,EAErCkB,EAAU,IAAIlB,CAAQ,EAAE,IAAIgC,CAAO,EAE9BD,EAAW,IAAIC,CAAO,GACvBD,EAAW,IAAIC,EAAS,IAAI,GAAK,EAErC,IAAIC,EAAmBF,EAAW,IAAIC,CAAO,EACxCC,EAAiB,IAAIjC,CAAQ,GAC9BiC,EAAiB,IAAIjC,EAAU,IAAI,GAAG,EAE1CiC,EAAiB,IAAIjC,CAAQ,EAAE,IAAIgB,CAAI,CAC3C,CAOA,SAASkB,GAAeF,EAAS,CAC7B,IAAIC,EAAmBF,EAAW,IAAIC,CAAO,EACzCC,GACAA,EAAiB,QAAQjC,GAAY,CACjCA,EAAS,QAAQmC,GAAK,CAClB,IAAIjB,EAAYY,EAAa,IAAIK,CAAC,EAC9BjB,EAAU,IAAIlB,CAAQ,GACtBkB,EAAU,IAAIlB,CAAQ,EAAE,OAAOgC,CAAO,CAE9C,CAAC,CACL,CAAC,CAET,CAMA,IAAIP,EAAe,CAAC,EAOdW,EAAc,CAAC,EAQrB,IAAMC,EAAc,CAAC,EAgId,SAASC,EAAgBC,EAAIC,EAAc,CAC9C,GAAIC,EAAY,UAAUC,GAAKH,GAAIG,CAAC,IAAI,GACpC,MAAM,IAAI,MAAM,0BAA2B,CAAC,MAAMH,CAAE,CAAC,EAEzDE,EAAY,KAAKF,CAAE,EAEnB,IAAII,EAAkBC,EAAQ,IAAIL,CAAE,EAC/BI,IACDA,EAAkBE,EAAO,CACrB,QAAS,IACb,CAAC,EACDD,EAAQ,IAAIL,EAAII,CAAe,GAGnC,IAAIG,EAAY,GACZC,EAAY,GA2ChB,OAxCsB,SAASC,GAAgB,CAC3C,GAAIC,EAAY,UAAUC,GAAKA,GAAGP,CAAe,IAAI,GACjD,MAAM,IAAI,MAAM,uCAAwC,CAAE,MAAOJ,CAAE,CAAC,EAExE,GAAIO,GAAaA,EAAU,KAAK,IAAI,EAAG,CACnCC,EAAY,GACZ,MACJ,CAEAI,GAAeH,CAAa,EAE5BI,EAAa,KAAKJ,CAAa,EAE/BC,EAAY,KAAKN,CAAe,EAEhC,IAAIU,EACJ,GAAI,CACAA,EAASd,EAAGS,EAAeI,EAAcH,CAAW,CACxD,QAAE,CACEF,EAAY,GAEZK,EAAa,IAAI,EAEjBH,EAAY,IAAI,EACZI,aAAkB,QAClBA,EAAO,KAAMA,GAAW,CACpBV,EAAgB,QAAUU,CAC9B,CAAC,EAEDV,EAAgB,QAAUU,CAElC,CACAP,EAAY,KAAK,IAAI,EAAEN,EACvB,WAAW,WAAW,IAAM,CACpBO,GACAC,EAAc,CAEtB,EAAGR,CAAY,CACnB,EAEc,EACPG,CACX,CC3cA,IAAMW,EAAN,KAAiB,CACb,YAAYC,EAAS,CACjB,IAAMC,EAAiB,CACnB,UAAW,SAAS,KACpB,UAAW,YACX,aAAc,CAAC,EACf,oBAAqB,CAACC,EAAkB,CAC5C,EACA,GAAI,CAACF,GAAS,KACV,MAAM,IAAI,MAAM,sCAAsC,EAE1D,KAAK,QAAU,OAAO,OAAO,CAAC,EAAGC,EAAgBD,CAAO,EAExD,IAAMG,EAAY,KAAK,QAAQ,UAIzBC,EAAUC,GAAO,CACnBC,EAAgB,IAAM,CAClB,IAAMC,EAAU,CACZ,UAAWF,EAAG,iBAAiB,mBAAmB,EAClD,KAAM,KAAK,eAAeA,CAAE,CAChC,EACAE,EAAQ,MAAQC,EAAe,KAAK,QAAQ,KAAMD,EAAQ,IAAI,EAC9DA,EAAQ,QAAUF,EAClBI,EAAgBF,CAAO,CAC3B,EAAG,GAAG,CACV,EAMME,EAAmBF,GAAY,CACjC,IAAIG,EAAe,KAAK,QAAQ,qBAAuB,CAAC,EACpDH,EAAQ,QAAQ,QAAQ,WACxBA,EAAQ,QAAQ,QAAQ,UAAU,MAAM,GAAG,EAAE,OAAO,OAAO,EAAE,QAAQI,GAAK,CAClE,KAAK,QAAQ,aAAaA,CAAC,EAC3BD,EAAa,KAAK,KAAK,QAAQ,aAAaC,CAAC,CAAC,EAE9C,QAAQ,KAAK,4BAA4BA,EAAE,cAAe,CAAC,MAAMJ,EAAQ,OAAO,CAAC,CAEzF,CAAC,EAEL,IAAIK,EACJ,QAASC,KAAeH,EACpBE,GAAQ,CAACA,EAAMC,IACHN,GACGM,EAAY,KAAK,KAAMN,EAASK,CAAI,GAEhDA,EAAMC,CAAW,EAExBD,EAAKL,CAAO,CAChB,EAIMO,EAAiBC,GAAa,CAChC,QAASC,KAAaD,EAClBX,EAAOY,CAAS,CAExB,EAKMC,EAAkBC,GAAY,CAChC,QAAWC,KAAUD,EACjB,GAAIC,EAAO,MAAM,aAAeA,EAAO,YACnC,QAASC,KAAQD,EAAO,WACpB,GAAIC,aAAgB,YAAa,CAC7B,IAAIL,EAAW,MAAM,KAAKK,EAAK,iBAAiB,IAAIjB,CAAS,GAAG,CAAC,EAC7DiB,EAAK,QAAQ,IAAIjB,CAAS,GAAG,GAC7BY,EAAS,QAAQK,CAAI,EAErBL,EAAS,QACTD,EAAcC,CAAQ,CAE9B,EAIhB,EAIiB,IAAI,iBAAkBG,GAAY,CAC/CD,EAAeC,CAAO,CAC1B,CAAC,EAEQ,QAAQlB,EAAQ,UAAW,CAChC,QAAS,GACT,UAAW,EACf,CAAC,EAKD,IAAMe,EAAW,KAAK,QAAQ,UAAU,iBAAiB,IAAI,KAAK,QAAQ,UAAU,iBAAiB,EACjGA,EAAS,QACTD,EAAcC,CAAQ,CAG9B,CAMA,cAAcM,EAAMC,EAAWC,EAAMC,EAAO,CACxC,IAAIC,EAAW,KAAK,aAAaH,EAAWC,EAAKC,CAAK,CAAC,EACvD,GAAI,CAACC,EAAU,CACX,IAAIC,EAAS,IAAI,iBACjB,OAAAA,EAAO,UAAY,gCACZA,CACX,CACA,IAAIC,EAAQF,EAAS,QAAQ,UAAU,EAAI,EAC3C,GAAI,CAACE,EAAM,UAAU,OACjB,MAAM,IAAI,MAAM,8CAA+C,CAAE,MAAOF,CAAS,CAAC,EAEtF,GAAIE,EAAM,SAAS,OAAO,EACtB,MAAM,IAAI,MAAM,2CAA4C,CAAE,MAAOF,CAAS,CAAC,EAEnF,IAAMV,EAAWY,EAAM,iBAAiB,IAAI,KAAK,QAAQ,UAAU,GAAG,EAChExB,EAAY,KAAK,QAAQ,UAC/B,QAASyB,KAAWb,EAAU,CAC1B,IAAMc,EAAOD,EAAQ,aAAazB,CAAS,EACvC0B,EAAK,UAAU,EAAG,CAAe,GAAG,SACpCD,EAAQ,aAAazB,EAAW0B,EAAK,UAAU,CAAe,CAAC,EACxDA,GAAM,SACbD,EAAQ,aAAazB,EAAWkB,EAAK,IAAIG,CAAK,EAE9CI,EAAQ,aAAazB,EAAWkB,EAAK,IAAIG,EAAM,IAAIK,CAAI,CAE/D,CACA,OAAAF,EAAM,SAAS,CAAC,EAAE,aAAaxB,EAAU,OAAOqB,CAAK,EAGrDG,EAAM,SAAS,CAAC,EAAE,cAAgBF,EAC3BE,CACX,CAEA,eAAetB,EAAI,CACf,OAAOA,EAAG,aAAa,KAAK,QAAQ,SAAS,CACjD,CAMA,aAAaiB,EAAWQ,EAAO,CAC3B,IAAMC,EAAkBpB,GAAK,CACzB,IAAIU,EAAO,KAAK,eAAeV,CAAC,EAChC,GAAI,CAACU,EACD,OAAOV,EAEX,IAAIqB,EACAX,EAAK,OAAO,EAAE,CAAC,GAAG,SAClBW,EAAcxB,EAAe,KAAK,QAAQ,KAAMa,CAAI,EAEpDW,EAAcxB,EAAesB,EAAOT,CAAI,EAE5C,IAAMY,EAAU,GAAGD,EACfE,EAAUvB,EAAE,aAAa,KAAK,QAAQ,UAAU,UAAU,EAC9D,GAAIuB,EAAS,CACT,GAAIA,IAAU,UAAY,CAACF,EACvB,OAAOrB,EAIX,GAHWuB,IAAU,aAAeF,GAGhCC,EAAQ,MAAMC,CAAO,EACrB,OAAOvB,CAEf,CACA,GAAI,CAACuB,GACGF,EACA,OAAOrB,CAGnB,EACIc,EAAW,MAAM,KAAKH,CAAS,EAAE,KAAKS,CAAe,EACrDI,EAAMV,GAAU,aAAa,KAAK,EACtC,GAAIU,EAAK,CACL,IAAIC,EAAc,SAAS,cAAc,YAAYD,CAAG,EACxD,GAAI,CAACC,EACD,MAAM,IAAI,MAAM,mCAAmCD,CAAG,EAE1DV,EAAWW,CACf,CACA,OAAOX,CACX,CAEJ,EAMO,SAASI,EAAK7B,EACrB,CACI,OAAO,IAAID,EAAWC,CAAO,CACjC,CAMO,SAASqC,EAAWC,EAAEC,EAAG,CAO5B,OANID,GAAG,UAAY,CAACC,GAGhBA,GAAG,UAAY,CAACD,GAGhB,GAAGA,GAAK,GAAGC,CAInB,CAQO,SAAS/B,EAAegC,EAAMnB,EACrC,CACI,IAAIoB,EAAQpB,EAAK,MAAM,GAAG,EACtBqB,EAAOF,EACPG,EAAMC,EACV,KAAOH,EAAM,QAAUC,GAAM,CAEzB,GADAC,EAAOF,EAAM,MAAM,EACfE,GAAM,OACN,OAAOC,EACJ,GAAID,GAAM,SACb,OAAOD,EACAC,GAAM,QACbD,EAAOF,GAEPG,EAAO,mBAAmBA,CAAI,EAC9BD,EAAOA,EAAKC,CAAI,EAChBC,EAAWD,EAEnB,CACA,OAAOD,CACX,CAMO,SAASxC,GAAmBK,EAAS,CACxC,IAAMF,EAAKE,EAAQ,QACbe,EAAYf,EAAQ,UACpBsC,EAAiBvB,EAAU,OAC3BD,EAAOd,EAAQ,KACfuB,EAAQvB,EAAQ,MAChBJ,EAAY,KAAK,QAAQ,UAC/B,OAAI,MAAM,QAAQ2B,CAAK,GAAKR,GAAW,OACnCwB,GAA0B,KAAK,KAAMvC,CAAO,EACrCuB,GAAS,OAAOA,GAAS,UAAYR,GAAW,OACvDyB,GAA2B,KAAK,KAAMxC,CAAO,EACtCF,EAAG,SAAS,QACnB2C,GAAe,KAAK,KAAMzC,CAAO,EAC1BF,EAAG,SAAS,SACnB4C,GAAgB,KAAK,KAAM1C,CAAO,EAC3BF,EAAG,SAAS,SACnB6C,GAAgB,KAAK,KAAM3C,CAAO,EAC3BF,EAAG,SAAS,IACnB8C,GAAgB,KAAK,KAAM5C,CAAO,EAElC6C,GAAiB,KAAK,KAAM7C,CAAO,EAEhCA,CACX,CAOO,SAASuC,GAA0BvC,EAAS,CAC/C,IAAMF,EAAiBE,EAAQ,QACzBe,EAAiBf,EAAQ,UACzBsC,EAAiBvB,EAAU,OAC3BD,EAAiBd,EAAQ,KACzBuB,EAAiBvB,EAAQ,MACzBJ,EAAiB,KAAK,QAAQ,UAEhCkD,EAAQhD,EAAG,iBAAiB,aAAaF,EAAU,OAAO,EAG1DmD,EAAU,EACVC,EAAU,EACd,QAASC,KAAQH,EAAO,CACpB,IAAII,EAAa,SAASD,EAAK,aAAarD,EAAU,MAAM,CAAC,EAC7D,GAAIsD,EAAWH,EAEXjD,EAAG,aAAa,KAAK,cAAcgB,EAAMC,EAAWQ,EAAOwB,CAAO,EAAGE,CAAI,UAClEC,EAAWH,EAElBE,EAAK,OAAO,MACT,CAEH,IAAIzC,EAAW,MAAM,KAAKyC,EAAK,iBAAiB,IAAIrD,CAAS,GAAG,CAAC,EAC7DqD,EAAK,QAAQ,IAAIrD,CAAS,GAAG,GAC7BY,EAAS,QAAQyC,CAAI,EAEzB,IAAIE,EAAmB3C,EAAS,KAAKwB,GAAK,CACtC,IAAIoB,EAAWpB,EAAE,aAAapC,CAAS,EACvC,OAAQwD,EAAS,OAAO,EAAE,CAAC,IAAI,SACxBA,EAAS,OAAO,EAAGtC,EAAK,MAAM,IAAIA,CAC7C,CAAC,EACD,GAAI,CAACqC,GACGF,EAAK,cAAe,CACpB,IAAII,EAAc,KAAK,aAAatC,EAAWQ,EAAMwB,CAAO,CAAC,EACzDM,GAAeJ,EAAK,gBACpBE,EAAmB,GACdE,GACDL,IAGZ,CAEAG,GACArD,EAAG,aAAa,KAAK,cAAcgB,EAAMC,EAAWQ,EAAOwB,CAAO,EAAGE,CAAI,CAEjF,CAEA,GADAF,IACIA,GAASxB,EAAM,OACf,KAER,CACAuB,EAAQhD,EAAG,iBAAiB,aAAaF,EAAU,OAAO,EAC1D,IAAI0D,EAASR,EAAM,OAASE,EAC5B,GAAIM,EAAS/B,EAAM,OACf,KAAO+B,EAAS/B,EAAM,QACNzB,EAAG,iBAAiB,yBAAyB,IAAIwD,EAAO,CAAC,GAC9D,OAAO,EACdA,YAEGA,EAAS/B,EAAM,OACtB,KAAO+B,EAAS/B,EAAM,QAClBzB,EAAG,YAAY,KAAK,cAAcgB,EAAMC,EAAWQ,EAAO+B,CAAM,CAAC,EACjEA,GAGZ,CAOO,SAASd,GAA2BxC,EAAS,CAChD,IAAMF,EAAiBE,EAAQ,QACzBe,EAAiBf,EAAQ,UACzBsC,EAAiBvB,EAAU,OAC3BD,EAAiBd,EAAQ,KACzBuB,EAAiBvB,EAAQ,MACzBJ,EAAiB,KAAK,QAAQ,UAEhCoB,EAAU,OAAO,QAAQO,CAAK,EAC9BuB,EAAUhD,EAAG,iBAAiB,aAAaF,EAAU,OAAO,EAC5D2D,EAAU,EACVP,EAAU,EACd,QAASC,KAAQH,EAAO,CACpB,GAAIS,GAASvC,EAAK,OACd,MAEJ,IAAIwC,EAAMxC,EAAKuC,CAAO,EAAE,CAAC,EACzBA,IACA,IAAIE,EAAU3C,EAAK,IAAI0C,EAEnBL,EACEC,EAAWH,EAAK,aAAarD,CAAS,EAC5C,GAAIwD,GAAYA,EAAS,OAAO,EAAGK,EAAQ,MAAM,GAAGA,EAChDN,EAAiB,WAGjBA,EADe,MAAM,KAAKF,EAAK,iBAAiB,IAAIrD,CAAS,GAAG,CAAC,EACrC,KAAKoC,GAAK,CAClC,IAAM0B,EAAK1B,EAAE,aAAapC,CAAS,EACnC,OAAQ8D,EAAG,OAAO,EAAE,CAAC,IAAI,SAAWA,EAAG,OAAO,EAAGD,EAAQ,MAAM,IAAIA,CACvE,CAAC,EACG,CAACN,GACGF,EAAK,cAAe,CACpB,IAAII,EAAc,KAAK,aAAatC,EAAWQ,EAAMiC,CAAG,CAAC,EACrDH,GAAeJ,EAAK,gBACpBE,EAAmB,GACdE,GACDL,IAGZ,CAGR,GAAIG,EAAkB,CAClB,IAAI/B,EAAQ,KAAK,cAAcN,EAAMC,EAAWQ,EAAOiC,CAAG,EAC1D1D,EAAG,aAAasB,EAAO6B,CAAI,CAC/B,CACJ,CACAH,EAAShD,EAAG,iBAAiB,aAAaF,EAAU,OAAO,EAC3D,IAAI0D,EAASR,EAAM,OAASE,EAC5B,GAAIM,EAAOtC,EAAK,OACZ,KAAOsC,EAAOtC,EAAK,QACHlB,EAAG,iBAAiB,yBAAyB,IAAIwD,EAAO,CAAC,GAC9D,OAAO,EACdA,YAEGA,EAAStC,EAAK,OACrB,KAAOsC,EAAStC,EAAK,QAAQ,CACzB,IAAIwC,EAAMxC,EAAKsC,CAAM,EAAE,CAAC,EACxBxD,EAAG,YAAY,KAAK,cAAcgB,EAAMC,EAAWQ,EAAOiC,CAAG,CAAC,EAC9DF,GACJ,CAER,CASO,SAASb,GAAezC,EAAS,CACpC,IAAMF,EAAQE,EAAQ,QAChBuB,EAAQvB,EAAQ,MAElBF,EAAG,MAAM,YAAcA,EAAG,MAAM,QAC5BgC,EAAWhC,EAAG,MAAOyB,CAAK,EAC1BzB,EAAG,QAAU,GAEbA,EAAG,QAAU,GAETgC,EAAWhC,EAAG,MAAOyB,CAAK,IAClCzB,EAAG,MAAQ,GAAGyB,EAEtB,CAKO,SAASmB,GAAgB1C,EAAS,CACrC,IAAMF,EAAQE,EAAQ,QAChBuB,EAAQvB,EAAQ,MAEjB8B,EAAWhC,EAAG,MAAMyB,CAAK,IAC1BzB,EAAG,MAAQ,GAAGyB,EAEtB,CAKO,SAASoB,GAAgB3C,EAAS,CACrC,IAAMF,EAAQE,EAAQ,QAChBuB,EAAQvB,EAAQ,MAEtB,GAAIF,EAAG,UACH,GAAI,MAAM,QAAQyB,CAAK,EACnB,QAASoC,KAAU7D,EAAG,QACdyB,EAAM,QAAQoC,EAAO,KAAK,IAAI,GAC9BA,EAAO,SAAW,GAElBA,EAAO,SAAW,OAI3B,CACH,IAAIA,EAAS7D,EAAG,QAAQ,KAAK8D,GAAK9B,EAAW8B,EAAE,MAAMrC,CAAK,CAAC,EACvDoC,IACAA,EAAO,SAAW,GAE1B,CACJ,CAMO,SAASf,GAAgB5C,EAAS,CACrC,IAAMF,EAAQE,EAAQ,QAChBuB,EAAQvB,EAAQ,MAElBuB,GAAO,WAAa,CAACO,EAAWhC,EAAG,UAAWyB,EAAM,SAAS,IAC7DzB,EAAG,UAAY,GAAGyB,EAAM,WAExBA,GAAO,MAAQ,CAACO,EAAWhC,EAAG,KAAKyB,EAAM,IAAI,IAC7CzB,EAAG,KAAO,GAAGyB,EAAM,KAE3B,CAKO,SAASsB,GAAiB7C,EAAS,CACtC,IAAMF,EAAQE,EAAQ,QAChBuB,EAAQvB,EAAQ,MAEjB8B,EAAWhC,EAAG,UAAWyB,CAAK,IAC/BzB,EAAG,UAAY,GAAGyB,EAE1B,CCnfA,IAAMsC,EAAN,KAAgB,CACf,YAAYC,EAAQ,CAAC,EAAG,CACvB,KAAK,UAAYA,EAAQ,WAAa,SAAS,KAC3CA,EAAQ,QACX,KAAK,MAAQC,EAAOD,EAAQ,KAAK,GAE9BA,EAAQ,WACX,KAAK,SAAWE,EAAS,CAAE,IAAK,KAAM,UAAW,KAAK,UAAW,SAAUF,EAAQ,QAAQ,CAAC,GAEzFA,EAAQ,OACX,KAAK,KAAOG,EAAK,CAAE,IAAK,KAAM,KAAMH,EAAQ,IAAK,CAAC,GAE/CA,EAAQ,SACX,KAAK,OAASI,EAAO,CAAE,IAAK,KAAM,OAAQJ,EAAQ,MAAM,CAAC,GAEtDA,EAAQ,UACX,KAAK,QAAUK,EAAQ,CAAC,IAAK,KAAM,QAASL,EAAQ,OAAO,CAAC,GAE7DM,EAAK,CAAE,UAAW,KAAK,UAAW,MAAO,KAAK,KAAM,CAAC,CACtD,CACD,EAEO,SAASC,GAAIP,EAAQ,CAAC,EAAG,CAC/B,OAAO,IAAID,EAAUC,CAAO,CAC7B",
  "names": ["routes", "options", "SimplyRoute", "parseRoutes", "path", "args", "matches", "getPath", "route", "params", "key", "i", "action", "routeRe", "getRegexpFromRoute", "result", "callback", "evt", "link", "getURL", "listener", "root", "routeInfo", "paths", "matchParams", "SimplyCommands", "options", "defaultHandlers", "commandHandler", "evt", "command", "getCommand", "stop", "fn", "commands", "handlers", "el", "i", "values", "option", "data", "input", "SimplyActions", "options", "actionHandler", "target", "property", "actions", "SimplyKeys", "options", "keyHandler", "keys", "selectedKeyboard", "key", "keyboard", "source", "iterate", "signalHandler", "target", "property", "receiver", "value", "notifyGet", "args", "l", "result", "notifySet", "makeContext", "signal", "current", "signals", "descriptor", "v", "batchedListeners", "batchMode", "self", "context", "listeners", "change", "propListeners", "getListeners", "listener", "addContext", "currentEffect", "computeStack", "clearContext", "prop", "currentCompute", "setListeners", "listenersMap", "computeMap", "compute", "connectedSignals", "clearListeners", "s", "effectStack", "signalStack", "throttledEffect", "fn", "throttleTime", "effectStack", "f", "connectedSignal", "signals", "signal", "throttled", "hasChange", "computeEffect", "signalStack", "s", "clearListeners", "computeStack", "result", "SimplyBind", "options", "defaultOptions", "defaultTransformer", "attribute", "render", "el", "throttledEffect", "context", "getValueByPath", "runTransformers", "transformers", "t", "next", "transformer", "applyBindings", "bindings", "bindingEl", "updateBindings", "changes", "change", "node", "path", "templates", "list", "index", "template", "result", "clone", "binding", "bind", "value", "templateMatches", "currentItem", "strItem", "matches", "rel", "replacement", "matchValue", "a", "b", "root", "parts", "curr", "part", "prevPart", "templatesCount", "transformArrayByTemplates", "transformObjectByTemplates", "transformInput", "transformButton", "transformSelect", "transformAnchor", "transformElement", "items", "lastKey", "skipped", "item", "currentKey", "needsReplacement", "databind", "newTemplate", "length", "current", "key", "keypath", "db", "option", "o", "SimplyApp", "options", "signal", "commands", "keys", "routes", "actions", "bind", "app"]
}
