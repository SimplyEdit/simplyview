{
  "version": 3,
  "sources": ["../src/route.mjs", "../src/command.mjs", "../src/action.mjs", "../src/key.mjs", "../src/state.mjs", "../src/bind.mjs", "../src/app.mjs"],
  "sourcesContent": ["export function routes(options) {\n\treturn new SimplyRoute(options)\n}\n\nclass SimplyRoute {\n\tconstructor(options={}) {\n\t\tthis.root = options.root || '/'\n        this.app = options.app\n\t\tthis.clear()\n\t\tif (options.routes) {\n\t\t\tthis.load(options.routes)\n\t\t}\n\t}\n\n\tload(routes) {\n\t\tparseRoutes(routes, this.routeInfo)\n\t}\n\n\tclear() {\n\t\tthis.routeInfo = []\n\t\tthis.listeners = {\n\t\t\tmatch: {},\n\t\t\tcall: {},\n\t\t\tfinish: {}\n\t\t}\n\t}\n\n\tmatch(path, options) {\n\t\tlet args = {\n            path,\n            options\n        }\n        args = this.runListeners('match',args)\n        path = args.path ? args.path : path;\n\n        let matches;\n        if (!path) {\n            if (this.match(document.location.pathname+document.location.hash)) {\n                return true;\n            } else {\n                return this.match(document.location.pathname);\n            }\n        }\n        path = getPath(path);\n        for ( let route of this.routeInfo) {\n            matches = route.match.exec(path)\n            if (matches && matches.length) {\n                var params = {};\n                route.params.forEach((key, i) => {\n                    if (key=='*') {\n                        key = 'remainder'\n                    }\n                    params[key] = matches[i+1]\n                })\n                Object.assign(params, options)\n                args.route = route\n                args.params = params\n                args = this.runListeners('call', args)\n                params = args.params ? args.params : params\n                args.result = route.action.call(route, params)\n                this.runListeners('finish', args)\n                return args.result\n            }\n        }\n        if (path && path[path.length-1]!='/') {\n        \treturn this.match(path+'/', options)\n        }\n        return false\n\t}\n\n\trunListeners(action, params) {\n        if (!Object.keys(this.listeners[action])) {\n            return\n        }\n        Object.keys(this.listeners[action]).forEach((route) => {\n            var routeRe = getRegexpFromRoute(route);\n            if (routeRe.exec(params.path)) {\n                var result;\n                for (let callback of this.listeners[action][route]) {\n                    result = callback.call(this.app, params)\n                    if (result) {\n                        params = result\n                    }\n                }\n            }\n        })\n        return params\n    }\n\n    handleEvents() {\n        globalThis.addEventListener('popstate', () => {\n            if (this.match(getPath(document.location.pathname + document.location.hash, this.root)) === false) {\n                this.match(getPath(document.location.pathname, this.root))\n            }\n        })\n        globalThis.document.addEventListener('click', (evt) => {\n\t        if (evt.ctrlKey) {\n\t            return;\n\t        }\n\t        if (evt.which != 1) {\n\t            return; // not a 'left' mouse click\n\t        }\n\t        var link = evt.target;\n\t        while (link && link.tagName!='A') {\n\t            link = link.parentElement;\n\t        }\n\t        if (link \n\t            && link.pathname \n\t            && link.hostname==globalThis.location.hostname \n\t            && !link.link\n\t            && !link.dataset.simplyCommand\n\t        ) {\n\t            let path = getPath(link.pathname+link.hash, this.root);\n\t            if ( !this.has(path) ) {\n\t                path = getPath(link.pathname, this.root);\n\t            }\n\t            if ( this.has(path) ) {\n\t                let params = this.runListeners('goto', { path: path});\n\t                if (params.path) {\n\t                    this.goto(params.path);\n\t                }\n\t                evt.preventDefault();\n\t                return false;\n\t            }\n\t        }\n\t    })\n    }\n\n    goto(path) {\n        history.pushState({},'',getURL(path))\n        return this.match(path)\n    }\n\n    has(path) {\n    \tpath = getPath(path, this.root)\n    \tfor (let route of this.routeInfo) {\n            var matches = route.match.exec(path)\n            if (matches && matches.length) {\n                return true\n            }\n        }\n        return false\n    }\n\n    addListener(action, route, callback) {\n        if (['goto','match','call','finish'].indexOf(action)==-1) {\n            throw new Error('Unknown action '+action)\n        }\n        if (!this.listeners[action][route]) {\n            this.listeners[action][route] = []\n        }\n        this.listeners[action][route].push(callback)\n    }\n\n    removeListener(action, route, callback) {\n        if (['match','call','finish'].indexOf(action)==-1) {\n            throw new Error('Unknown action '+action)\n        }\n        if (!this.listeners[action][route]) {\n            return\n        }\n        this.listeners[action][route] = this.listeners[action][route].filter((listener) => {\n            return listener != callback\n        })\n    }\n\n    init(options) {\n    \tif (options.root) {\n    \t\tthis.root = options.root\n    \t}\n    }\n}\n\nfunction getPath(path, root='/') {\n    if (path.substring(0,root.length)==root\n        ||\n        ( root[root.length-1]=='/' \n            && path.length==(root.length-1)\n            && path == root.substring(0,path.length)\n        )\n    ) {\n        path = path.substring(root.length)\n    }\n    if (path[0]!='/' && path[0]!='#') {\n        path = '/'+path\n    }\n    return path\n}\n\nfunction getURL(path, root) {\n    path = getPath(path, root)\n    if (root[root.length-1]==='/' && path[0]==='/') {\n        path = path.substring(1)\n    }\n    return root + path;\n}\n\nfunction getRegexpFromRoute(route) {\n    return new RegExp('^'+route.replace(/:\\w+/g, '([^/]+)').replace(/:\\*/, '(.*)'));\n}\n\nfunction parseRoutes(routes) {\n    let routeInfo = []\n    const paths = Object.keys(routes)\n    const matchParams = /:(\\w+|\\*)/g\n    for (let path of paths) {\n        let matches = []\n        let params  = []\n        do {\n            matches = matchParams.exec(path)\n            if (matches) {\n                params.push(matches[1])\n            }\n        } while(matches)\n        routeInfo.push({\n            match:  getRegexpFromRoute(path),\n            params: params,\n            action: routes[path]\n        })\n    }\n    return routeInfo\n}\n", "class SimplyCommands {\n\tconstructor(options={}) {\n\t\tif (!options.app) {\n\t\t\toptions.app = {}\n\t\t}\n\t\tif (!options.app.container) {\n\t\t\toptions.app.container = document.body\n\t\t}\n\t\tthis.$handlers = options.handlers || defaultHandlers\n        if (options.commands) {\n    \t\tObject.assign(this, options.commands)\n        }\n\n\t\tconst commandHandler = (evt) => {\n\t\t\tconst command = getCommand(evt, this.$handlers)\n\t\t\tif (!command) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (!this[command.name]) {\n                console.error('simply.command: undefined command '+command.name, command.source);\n                return\n\t\t\t}\n            const shouldContinue = this[command.name].call(options.app, command.source, command.value)\n            if (shouldContinue!==true) {\n                evt.preventDefault()\n                evt.stopPropagation()\n                return false\n            }\n\t\t}\n\n        options.app.container.addEventListener('click', commandHandler)\n        options.app.container.addEventListener('submit', commandHandler)\n        options.app.container.addEventListener('change', commandHandler)\n        options.app.container.addEventListener('input', commandHandler)\n\t}\n}\n\nexport function commands(options={}) {\n\treturn new SimplyCommands(options)\n}\n\nfunction getCommand(evt, handlers) {\n    var el = evt.target.closest('[data-simply-command]')\n    if (el) {\n        for (let handler of handlers) {\n            if (el.matches(handler.match)) {\n                if (handler.check(el, evt)) {\n                    return {\n                        name:   el.dataset.simplyCommand,\n                        source: el,\n                        value:  handler.get(el)\n                    }\n                }\n                return null\n            }\n        }\n    }\n    return null\n}\n\nconst defaultHandlers = [\n    {\n        match: 'input,select,textarea',\n        get: function(el) {\n            if (el.tagName==='SELECT' && el.multiple) {\n                let values = []\n                for (let option of el.options) {\n                    if (option.selected) {\n                        values.push(option.value)\n                    }\n                }\n                return values\n            }\n            return el.dataset.simplyValue || el.value\n        },\n        check: function(el, evt) {\n            return evt.type=='change' || (el.dataset.simplyImmediate && evt.type=='input')\n        }\n    },\n    {\n        match: 'a,button',\n        get: function(el) {\n            return el.dataset.simplyValue || el.href || el.value\n        },\n        check: function(el,evt) {\n            return evt.type=='click' && evt.ctrlKey==false && evt.button==0\n        }\n    },\n    {\n        match: 'form',\n        get: function(el) {\n            let data = {}\n            for (let input of Array.from(el.elements)) {\n                if (input.tagName=='INPUT' \n                    && (input.type=='checkbox' || input.type=='radio')\n                ) {\n                    if (!input.checked) {\n                        return;\n                    }\n                }\n                if (data[input.name] && !Array.isArray(data[input.name])) {\n                    data[input.name] = [data[input.name]]\n                }\n                if (Array.isArray(data[input.name])) {\n                    data[input.name].push(input.value)\n                } else {\n                    data[input.name] = input.value\n                }\n            }\n            return data\n        },\n        check: function(el,evt) {\n            return evt.type=='submit'\n        }\n    },\n    {\n    \tmatch: '*',\n        get: function(el) {\n            return el.dataset.simplyValue\n        },\n        check: function(el, evt) {\n            return evt.type=='click' && evt.ctrlKey==false && evt.button==0\n        }\n    }\n]", "export function actions(options) {\n\tif (options.app) {\n\t\tconst actionHandler = {\n\t\t\tget: (target, property) => {\n\t\t\t\treturn target[property].bind(options.app)\n\t\t\t}\n\t\t}\n\t\treturn new Proxy(options.actions, actionHandler)\n\t} else {\n\t\treturn options\n\t}\n}", "class SimplyKeys {\n\tconstructor(options = {}) {\n\t\tif (!options.app) {\n\t\t\toptions.app = {}\n\t\t}\n\t\tif (!options.app.container) {\n\t\t\toptions.app.container = document.body\n\t\t}\n\t\tObject.assign(this, options.keys)\n\n\t\tconst keyHandler = (e) => {\n\t\t\tif (e.isComposing || e.keyCode === 229) {\n\t\t\t    return;\n\t\t\t}\n\t\t\tif (e.defaultPrevented) {\n\t\t\t    return;\n\t\t\t}\n\t\t\tif (!e.target) {\n\t\t\t    return;\n\t\t\t}\n\n\t\t\tlet selectedKeyboard = 'default';\n\t\t\tif (e.target.closest('[data-simply-keyboard]')) {\n\t\t\t    selectedKeyboard = e.target.closest('[data-simply-keyboard]').dataset.simplyKeyboard;\n\t\t\t}\n\t\t\tlet key = '';\n\t\t\tif (e.ctrlKey && e.keyCode!=17) {\n\t\t\t    key+='Control+';\n\t\t\t}\n\t\t\tif (e.metaKey && e.keyCode!=224) {\n\t\t\t    key+='Meta+';\n\t\t\t}\n\t\t\tif (e.altKey && e.keyCode!=18) {\n\t\t\t    key+='Alt+';\n\t\t\t}\n\t\t\tif (e.shiftKey && e.keyCode!=16) {\n\t\t\t    key+='Shift+';\n\t\t\t}\n\t\t\tkey+=e.key;\n\n\t\t\tif (this[selectedKeyboard] && this[selectedKeyboard][key]) {\n\t\t\t    let keyboard = this[selectedKeyboard]\n\t\t\t    keyboard[key].call(options.app,e);\n\t\t\t}\n\t\t}\n\n\t\toptions.app.container.addEventListener('keydown', keyHandler)\n\t}\n\n}\n\nexport function keys(options={}) {\n\treturn new SimplyKeys(options)\n}\n\n", "const iterate = Symbol('iterate')\nif (!Symbol.xRay) {\n    Symbol.xRay = Symbol('xRay')\n}\n\nconst signalHandler = {\n    get: (target, property, receiver) => {\n        if (property===Symbol.xRay) {\n            return target // don't notifyGet here, this is only called by set\n        }\n        const value = target?.[property] // Reflect.get fails on a Set.\n        notifyGet(receiver, property)\n        if (typeof value === 'function') {\n            if (Array.isArray(target)) {\n                return (...args) => {\n                    let l = target.length\n                    // by binding the function to the receiver\n                    // all accesses in the function will be trapped\n                    // by the Proxy, so get/set/delete is all handled\n                    let result = value.apply(receiver, args)\n                    if (l != target.length) {\n                        notifySet(receiver,  makeContext('length', { was: l, now: target.length }) )\n                    }\n                    return result\n                }\n            } else if (target instanceof Set || target instanceof Map) {\n                return (...args) => {\n                    // node doesn't allow you to call set/map functions\n                    // bound to the receiver.. so using target instead\n                    // there are no properties to update anyway, except for size\n                    let s = target.size\n                    let result = value.apply(target, args)\n                    if (s != target.size) {\n                        notifySet(receiver, makeContext( 'size', { was: s, now: target.size }) )\n                    }\n                    // there is no efficient way to see if the function called\n                    // has actually changed the Set/Map, but by assuming the\n                    // 'setter' functions will change the results of the\n                    // 'getter' functions, effects should update correctly\n                    if (['set','add','clear','delete'].includes(property)) {\n                        notifySet(receiver, makeContext( { entries: {}, forEach: {}, has: {}, keys: {}, values: {}, [Symbol.iterator]: {} } ) )\n                    }\n                    return result\n                }\n            } else if (\n                target instanceof HTMLElement\n                || target instanceof Number\n                || target instanceof String\n                || target instanceof Boolean\n            ) {\n                return value.bind(target)\n            } else {\n                // support custom classes, hopefully\n                return value.bind(receiver)\n            }\n        }\n        if (value && typeof value == 'object') {\n            //NOTE: get now returns a signal, set doesn't 'unsignal' the value set\n            return signal(value)\n        }\n        return value\n    },\n    set: (target, property, value, receiver) => {\n        value = value?.[Symbol.xRay] || value // unwraps signal\n        let current = target[property]\n        if (current!==value) {\n            target[property] = value\n            notifySet(receiver, makeContext(property, { was: current, now: value } ) )\n        }\n        if (typeof current === 'undefined') {\n            notifySet(receiver, makeContext(iterate, {}))\n        }\n        return true\n    },\n    has: (target, property) => { // receiver is not part of the has() call\n        let receiver = signals.get(target) // so retrieve it here\n        if (receiver) {\n            notifyGet(receiver, property)\n        }\n        return Object.hasOwn(target, property)\n    },\n    deleteProperty: (target, property) => {\n        if (typeof target[property] !== 'undefined') {\n            let current = target[property]\n            delete target[property]\n            let receiver = signals.get(target) // receiver is not part of the trap arguments, so retrieve it here\n            notifySet(receiver, makeContext(property,{ delete: true, was: current }))\n        }\n        return true\n    },\n    defineProperty: (target, property, descriptor) => {\n        if (typeof target[property] === 'undefined') {\n            let receiver = signals.get(target) // receiver is not part of the trap arguments, so retrieve it here\n            notifySet(receiver, makeContext(iterate, {}))\n        }\n        return Object.defineProperty(target, property, descriptor)\n    },\n    ownKeys: (target) => {\n        let receiver = signals.get(target) // receiver is not part of the trap arguments, so retrieve it here\n        notifyGet(receiver, iterate)\n        return Reflect.ownKeys(target)\n    }\n\n}\n\n/**\n * Keeps track of the return signal for an update function, as well\n * as signals connected to other objects. \n * Makes sure that a given object or function always uses the same\n * signal\n */\nconst signals = new WeakMap()\n\n/**\n * Creates a new signal proxy of the given object, that intercepts get/has and set/delete\n * to allow reactive functions to be triggered when signal values change.\n */\nexport function signal(v) {\n    if (!signals.has(v)) {\n        signals.set(v, new Proxy(v, signalHandler))\n    }\n    return signals.get(v)\n}\n\nlet batchedListeners = new Set()\nlet batchMode = 0\n/**\n * Called when a signal changes a property (set/delete)\n * Triggers any reactor function that depends on this signal\n * to re-compute its values\n */\nfunction notifySet(self, context={}) {\n    let listeners = []\n    context.forEach((change, property) => {\n        let propListeners = getListeners(self, property)\n        if (propListeners?.length) {\n            for (let listener of propListeners) {\n                addContext(listener, makeContext(property,change))\n            }\n            listeners = listeners.concat(propListeners)\n        }\n    })\n    listeners = new Set(listeners.filter(Boolean))\n    if (listeners) {\n        if (batchMode) {\n            batchedListeners = batchedListeners.union(listeners)\n        } else {\n            const currentEffect = computeStack[computeStack.length-1]\n            for (let listener of Array.from(listeners)) {\n                if (listener!=currentEffect && listener?.needsUpdate) {\n                    listener()\n                }\n                clearContext(listener)\n            }\n        }\n    }\n}\n\nfunction makeContext(property, change) {\n    let context = new Map()\n    if (typeof property === 'object') {\n        for (let prop in property) {\n            context.set(prop, property[prop])\n        }\n    } else {\n        context.set(property, change)\n    }\n    return context\n}\n\nfunction addContext(listener, context) {\n    if (!listener.context) {\n        listener.context = context\n    } else {\n        context.forEach((change,property)=> {\n            listener.context.set(property, change) // TODO: merge change if needed\n        })\n    }\n    listener.needsUpdate = true\n}\n\nfunction clearContext(listener) {\n    delete listener.context\n    delete listener.needsUpdate\n}\n\n/**\n * Called when a signal property is accessed. If this happens\n * inside a reactor function--computeStack is not empty--\n * then it adds the current reactor (top of this stack) to its\n * listeners. These are later called if this property changes\n */\nfunction notifyGet(self, property) {\n    let currentCompute = computeStack[computeStack.length-1]\n    if (currentCompute) {\n        // get was part of a react() function, so add it\n        setListeners(self, property, currentCompute)\n    }\n}\n\n/**\n * Keeps track of which update() functions are dependent on which\n * signal objects and which properties. Maps signals to update fns\n */\nconst listenersMap = new WeakMap()\n\n/**\n * Keeps track of which signals and properties are linked to which\n * update functions. Maps update functions and properties to signals\n */\nconst computeMap = new WeakMap()\n\n/**\n * Returns the update functions for a given signal and property\n */\nfunction getListeners(self, property) {\n    let listeners = listenersMap.get(self)\n    return listeners ? Array.from(listeners.get(property) || []) : []\n}\n\n/**\n * Adds an update function (compute) to the list of listeners on\n * the given signal (self) and property\n */\nfunction setListeners(self, property, compute) {\n    if (!listenersMap.has(self)) {\n        listenersMap.set(self, new Map())\n    }\n    let listeners = listenersMap.get(self)\n    if (!listeners.has(property)) {\n        listeners.set(property, new Set())\n    }\n    listeners.get(property).add(compute)\n\n    if (!computeMap.has(compute)) {\n        computeMap.set(compute, new Map())\n    }\n    let connectedSignals = computeMap.get(compute)\n    if (!connectedSignals.has(property)) {\n        connectedSignals.set(property, new Set)\n    }\n    connectedSignals.get(property).add(self)\n}\n\n/**\n * Removes alle listeners that trigger the given reactor function (compute)\n * This happens when a reactor is called, so that it can set new listeners\n * based on the current call (code path)\n */\nfunction clearListeners(compute) {\n    let connectedSignals = computeMap.get(compute)\n    if (connectedSignals) {\n        connectedSignals.forEach(property => {\n            property.forEach(s => {\n                let listeners = listenersMap.get(s)\n                if (listeners.has(property)) {\n                    listeners.get(property).delete(compute)\n                }\n            })\n        })\n    }\n}\n\n/**\n * The top most entry is the currently running update function, used\n * to automatically record signals used in an update function.\n */\nlet computeStack = []\n\n/**\n * Used for cycle detection: effectStack contains all running effect\n * functions. If the same function appears twice in this stack, there\n * is a recursive update call, which would cause an infinite loop.\n */\nconst effectStack = []\n\nconst effectMap = new WeakMap()\n/**\n * Used for cycle detection: signalStack contains all used signals. \n * If the same signal appears more than once, there is a cyclical \n * dependency between signals, which would cause an infinite loop.\n */\nconst signalStack = []\n\n/**\n * Runs the given function at once, and then whenever a signal changes that\n * is used by the given function (or at least signals used in the previous run).\n */\nexport function effect(fn) {\n    if (effectStack.findIndex(f => fn==f)!==-1) {\n        throw new Error('Recursive update() call', {cause:fn})\n    }\n    effectStack.push(fn)\n\n    let connectedSignal = signals.get(fn)\n    if (!connectedSignal) {\n        connectedSignal = signal({\n            current: null\n        })\n        signals.set(fn, connectedSignal)\n    }\n\n    // this is the function that is called automatically\n    // whenever a signal dependency changes\n    const computeEffect = function computeEffect() {\n        if (signalStack.findIndex(s => s==connectedSignal)!==-1) {\n            throw new Error('Cyclical dependency in update() call', { cause: fn})\n        }\n        // remove all dependencies (signals) from previous runs \n        clearListeners(computeEffect)\n        // record new dependencies on this run\n        computeStack.push(computeEffect)\n        // prevent recursion\n        signalStack.push(connectedSignal)\n        // call the actual update function\n        let result\n        try {\n            result = fn(computeEffect, computeStack, signalStack)\n        } finally {\n            // stop recording dependencies\n            computeStack.pop()\n            // stop the recursion prevention\n            signalStack.pop()\n            if (result instanceof Promise) {\n                result.then((result) => {\n                    connectedSignal.current = result\n                })\n            } else {\n                connectedSignal.current = result\n            }\n        }\n    }\n    computeEffect.fn = fn\n    effectMap.set(connectedSignal, computeEffect)\n\n    // run the computEffect immediately upon creation\n    computeEffect()\n    return connectedSignal\n}\n\n\nexport function destroy(connectedSignal) {\n    // find the computeEffect associated with this signal\n    const computeEffect = effectMap.get(connectedSignal)?.deref()\n    if (!computeEffect) {\n        return\n    }\n\n    // remove all listeners for this effect\n    clearListeners(computeEffect)\n\n    // remove all references to connectedSignal\n    let fn = computeEffect.fn\n    signals.remove(fn)\n\n    effectMap.delete(connectedSignal)\n\n    // if no other references to connectedSignal exist, it will be garbage collected\n}\n\n/**\n * Inside a batch() call, any changes to signals do not trigger effects\n * immediately. Instead, immediately after finishing the batch() call,\n * these effects will be called. Effects that are triggered by multiple\n * signals are called only once.\n * @param Function fn batch() calls this function immediately\n * @result mixed the result of the fn() function call\n */\nexport function batch(fn) {\n    batchMode++\n    let result\n    try {\n        result = fn()\n    } finally {\n        if (result instanceof Promise) {\n            result.then(() => {\n                batchMode--\n                if (!batchMode) {\n                    runBatchedListeners()\n                }\n            })\n        } else {\n            batchMode--\n            if (!batchMode) {\n                runBatchedListeners()\n            }\n        }\n    }\n    return result\n}\n\nfunction runBatchedListeners() {\n    let copyBatchedListeners = Array.from(batchedListeners)\n    batchedListeners = new Set()\n    const currentEffect = computeStack[computeStack.length-1]\n    for (let listener of copyBatchedListeners) {\n        if (listener!=currentEffect && listener?.needsUpdate) {\n            listener()\n        }\n        clearContext(listener)\n    }\n}\n\n/**\n * A throttledEffect is run immediately once. And then only once\n * per throttleTime (in ms).\n * @param Function fn the effect function to run whenever a signal changes\n * @param int throttleTime in ms\n * @returns signal with the result of the effect function fn\n */\nexport function throttledEffect(fn, throttleTime) {\n    if (effectStack.findIndex(f => fn==f)!==-1) {\n        throw new Error('Recursive update() call', {cause:fn})\n    }\n    effectStack.push(fn)\n\n    let connectedSignal = signals.get(fn)\n    if (!connectedSignal) {\n        connectedSignal = signal({\n            current: null\n        })\n        signals.set(fn, connectedSignal)\n    }\n\n    let throttled = false\n    let hasChange = true\n    // this is the function that is called automatically\n    // whenever a signal dependency changes\n    const computeEffect = function computeEffect() {\n        if (signalStack.findIndex(s => s==connectedSignal)!==-1) {\n            throw new Error('Cyclical dependency in update() call', { cause: fn})\n        }\n        if (throttled && throttled>Date.now()) {\n            hasChange = true\n            return\n        }\n        // remove all dependencies (signals) from previous runs \n        clearListeners(computeEffect)\n        // record new dependencies on this run\n        computeStack.push(computeEffect)\n        // prevent recursion\n        signalStack.push(connectedSignal)\n        // call the actual update function\n        let result\n        try {\n            result = fn(computeEffect, computeStack, signalStack)\n        } finally {\n            hasChange = false\n            // stop recording dependencies\n            computeStack.pop()\n            // stop the recursion prevention\n            signalStack.pop()\n            if (result instanceof Promise) {\n                result.then((result) => {\n                    connectedSignal.current = result\n                })\n            } else {\n                connectedSignal.current = result\n            }\n        }\n        throttled = Date.now()+throttleTime\n        globalThis.setTimeout(() => {\n            if (hasChange) {\n                computeEffect()\n            }\n        }, throttleTime)\n    }\n    // run the computEffect immediately upon creation\n    computeEffect()\n    return connectedSignal\n}\n\n// refactor: Class clock() with an effect() method\n// keep track of effects per clock, and add clock property to the effect function\n// on notifySet add clock.effects to clock.needsUpdate list\n// on clock.tick() (or clock.time++) run only the clock.needsUpdate effects \n// (first create a copy and reset clock.needsUpdate, then run effects)\nexport function clockEffect(fn, clock) {\n    let connectedSignal = signals.get(fn)\n    if (!connectedSignal) {\n        connectedSignal = signal({\n            current: null\n        })\n        signals.set(fn, connectedSignal)\n    }\n\n    let lastTick = -1 // clock.time should start at 0 or larger\n    let hasChanged = true // make sure the first run goes through\n    // this is the function that is called automatically\n    // whenever a signal dependency changes\n    const computeEffect = function computeEffect() {\n        if (lastTick < clock.time) {\n            if (hasChanged) {\n                // remove all dependencies (signals) from previous runs \n                clearListeners(computeEffect)\n                // record new dependencies on this run\n                computeStack.push(computeEffect)\n                // make sure the clock.time signal is a dependency\n                lastTick = clock.time\n                // call the actual update function\n                let result \n                try {\n                    result = fn(computeEffect, computeStack)\n                } finally {\n                    // stop recording dependencies\n                    computeStack.pop()\n                    if (result instanceof Promise) {\n                        result.then((result) => {\n                            connectedSignal.current = result\n                        })\n                    } else {\n                        connectedSignal.current = result\n                    }\n                    hasChanged = false\n                }\n            } else {\n                lastTick = clock.time\n            }\n        } else {\n            hasChanged = true\n        }\n    }\n    // run the computEffect immediately upon creation\n    computeEffect()\n    return connectedSignal\n}\n\nexport function untracked(fn) {\n    const remember = computeStack.slice()\n    computeStack = []\n    try {\n        return fn()\n    } finally {\n        computeStack = remember\n    }\n}", "import { throttledEffect, destroy } from './state.mjs'\n\nclass SimplyBind {\n    constructor(options) {\n        this.bindings = new Map()\n        const defaultOptions = {\n            container: document.body,\n            attribute: 'data-bind',\n            transformers: [],\n            defaultTransformers: {\n                field: [defaultFieldTransformer],\n                list: [defaultListTransformer],\n                map: [defaultMapTransformer]\n            }\n        }\n        if (!options?.root) {\n            throw new Error('bind needs at least options.root set')\n        }\n        this.options = Object.assign({}, defaultOptions, options)\n\n        const attribute      = this.options.attribute\n        const bindAttributes = [attribute+'-field',attribute+'-list',attribute+'-map']\n        const bindSelector   = `[${attribute}-field],[${attribute}-list],[${attribute}-map]`\n\n        const getBindingAttribute = (el) => {\n            const foundAttribute = bindAttributes.find(attr => el.hasAttribute(attr))\n            if (!foundAttribute) {\n                console.error('No matching attribute found',el)\n            }\n            return foundAttribute\n        }\n\n        // sets up the effect that updates the element if its\n        // data binding value changes\n\n        const render = (el) => {\n            this.bindings.set(el, throttledEffect(() => {\n                const context = {\n                    templates: el.querySelectorAll(':scope > template'),\n                    attribute: getBindingAttribute(el)\n                }\n                context.path = this.getBindingPath(el)\n                context.value = getValueByPath(this.options.root, context.path)\n                context.element = el\n                runTransformers(context)\n            }, 100))\n        }\n\n        // finds and runs applicable transformers\n        // creates a stack of transformers, calls the topmost\n        // each transformer can opt to call the next or not\n        // transformers should return the context object (possibly altered)\n        const runTransformers = (context) => {\n            let transformers\n            switch(context.attribute) {\n                case this.options.attribute+'-field':\n                    transformers = this.options.defaultTransformers.field || []\n                    break\n                case this.options.attribute+'-list':\n                    transformers = this.options.defaultTransformers.list || []\n                    break\n                case this.options.attribute+'-map':\n                    transformers = this.options.defaultTransformers.map || []\n                    break\n            }\n            if (context.element.dataset.transform) {\n                context.element.dataset.transform.split(' ').filter(Boolean).forEach(t => {\n                    if (this.options.transformers[t]) {\n                        transformers.push(this.options.transformers[t])\n                    } else {\n                        console.warn('No transformer with name '+t+' configured', {cause:context.element})\n                    }\n                })\n            }\n            let next\n            for (let transformer of transformers) {\n                next = ((next, transformer) => {\n                    return (context) => {\n                        return transformer.call(this, context, next)\n                    }\n                })(next, transformer)\n            }\n            next(context)\n        }\n\n        // given a set of elements with data bind attribute\n        // this renders each of those elements\n        const applyBindings = (bindings) => {\n            for (let bindingEl of bindings) {\n                render(bindingEl)\n            }\n        }\n\n        // this handles the mutation observer changes\n        // if any element is added, and has a data bind attribute\n        // it applies that data binding\n        const updateBindings = (changes) => {\n            const selector = `[${attribute}-field],[${attribute}-list],[${attribute}-map]`\n            for (const change of changes) {\n                if (change.type==\"childList\" && change.addedNodes) {\n                    for (let node of change.addedNodes) {\n                        if (node instanceof HTMLElement) {\n                            let bindings = Array.from(node.querySelectorAll(selector))\n                            if (node.matches(selector)) {\n                                bindings.unshift(node)\n                            }\n                            if (bindings.length) {\n                                applyBindings(bindings)\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // this responds to elements getting added to the dom\n        // and if any have data bind attributes, it applies those bindings\n        this.observer = new MutationObserver((changes) => {\n            updateBindings(changes)\n        })\n\n        this.observer.observe(options.container, {\n            subtree: true,\n            childList: true\n        })\n\n        // this finds elements with data binding attributes and applies those bindings\n        // must come after setting up the observer, or included templates\n        // won't trigger their own bindings\n        const bindings = this.options.container.querySelectorAll(\n            '['+this.options.attribute+'-field]'+\n            ',['+this.options.attribute+'-list]'+\n            ',['+this.options.attribute+'-map]'\n        )\n        if (bindings.length) {\n            applyBindings(bindings)\n        }\n\n    }\n\n    /**\n     * Finds the first matching template and creates a new DocumentFragment\n     * with the correct data bind attributes in it (prepends the current path)\n     */\n    applyTemplate(context) {\n        const path      = context.path\n        const templates = context.templates\n        const list      = context.list\n        const index     = context.index\n        const parent    = context.parent\n        const value     = list ? list[index] : context.value\n\n        let template = this.findTemplate(templates, value)\n        if (!template) {\n            let result = new DocumentFragment()\n            result.innerHTML = '<!-- no matching template -->'\n            return result\n        }\n        let clone = template.content.cloneNode(true)\n        if (!clone.children?.length) {\n            throw new Error('template must contain a single html element', { cause: template })\n        }\n        if (clone.children.length>1) {\n            throw new Error('template must contain a single root node', { cause: template })\n        }\n        const attribute = this.options.attribute\n        const attributes = [attribute+'-field',attribute+'-list',attribute+'-map']\n        const bindings = clone.querySelectorAll(`[${attribute}-field],[${attribute}-list],[${attribute}-map]`)\n        for (let binding of bindings) {\n            const attr = attributes.find(attr => binding.hasAttribute(attr))\n            const bind = binding.getAttribute(attr)\n            if (bind.substring(0, '#root.'.length)=='#root.') {\n                binding.setAttribute(attr, bind.substring('#root.'.length))\n            } else if (bind=='#value' && index!=null) {\n                binding.setAttribute(attr, path+'.'+index)\n            } else if (index!=null) {\n                binding.setAttribute(attr, path+'.'+index+'.'+bind)\n            } else {\n                binding.setAttribute(attr, parent+'.'+bind)\n            }\n        }\n        if (typeof index !== 'undefined') {\n            clone.children[0].setAttribute(attribute+'-key',index)\n        }\n        // keep track of the used template, so if that changes, the \n        // item can be updated\n        clone.children[0].$bindTemplate = template\n        return clone\n    }\n\n    getBindingPath(el) {\n        const attributes = [\n            this.options.attribute+'-field', \n            this.options.attribute+'-list',\n            this.options.attribute+'-map'\n        ]\n        for (let attr of attributes) {\n            if (el.hasAttribute(attr)) {\n                return el.getAttribute(attr)\n            }\n        }\n    }\n\n    /**\n     * Finds the first template from an array of templates that\n     * matches the given value. \n     */\n    findTemplate(templates, value) {\n        const templateMatches = t => {\n            // find the value to match against (e.g. data-bind=\"foo\")\n            let path = this.getBindingPath(t)\n            let currentItem\n            if (path) {\n                if (path.substr(0,6)=='#root.') {\n                    currentItem = getValueByPath(this.options.root, path)\n                } else {\n                    currentItem = getValueByPath(value, path)\n                }\n            } else {\n                currentItem = value\n            }\n\n            // then check the value against pattern, if set (e.g. data-bind-match=\"bar\")\n            const strItem = ''+currentItem\n            let matches = t.getAttribute(this.options.attribute+'-match')\n            if (matches) {\n                if (matches==='#empty' && !currentItem) {\n                    return t\n                } else if (matches==='#notempty' && currentItem) {\n                    return t\n                }\n                if (strItem.match(matches)) {\n                    return t\n                }\n            }\n            if (!matches && currentItem!==null && currentItem!==undefined) {\n                //FIXME: this doesn't run templates in lists where list entry is null\n                //which messes up the count\n                //\n                // no data-bind-match is set, so return this template\n                return t\n            }\n        }\n        let template = Array.from(templates).find(templateMatches)\n        let rel = template?.getAttribute('rel')\n        if (rel) {\n            let replacement = document.querySelector('template#'+rel)\n            if (!replacement) {\n                throw new Error('Could not find template with id '+rel)\n            }\n            template = replacement\n        }\n        return template\n    }\n\n    destroy() {\n        this.bindings.forEach(binding => {\n            destroy(binding)\n        })\n        this.bindings = new Map()\n        this.observer.disconnect()\n    }\n\n}\n\n/**\n * Returns a new instance of SimplyBind. This is the normal start\n * of a data bind flow\n */\nexport function bind(options)\n{\n    return new SimplyBind(options)\n}\n\n/**\n * Returns true if a matches b, either by having the\n * same string value, or matching string #empty against a falsy value\n */\nexport function matchValue(a,b) {\n    if (a=='#empty' && !b) {\n        return true\n    }\n    if (b=='#empty' && !a) {\n        return true\n    }\n    if (''+a == ''+b) {\n        return true\n    }\n    return false\n}\n\n/**\n * Returns the value by walking the given path\n * as a json pointer, starting at root\n * if you have a property with a '.' in its name\n * urlencode the '.', e.g: %46\n */\nexport function getValueByPath(root, path)\n{\n    let parts = path.split('.');\n    let curr = root;\n    let part, prevPart;\n    while (parts.length && curr) {\n        part = parts.shift()\n        if (part=='#key') {\n            return prevPart\n        } else if (part=='#value') {\n            return curr\n        } else if (part=='#root') {\n            curr = root\n        } else {\n            part = decodeURIComponent(part)\n            curr = curr[part];\n            prevPart = part\n        }\n    }\n    return curr\n}\n\n/**\n * Default transformer for data binding\n * Will be used unless overriden in the SimplyBind options parameter\n */\nexport function defaultFieldTransformer(context) {\n    const el             = context.element\n    const templates      = context.templates\n    const templatesCount = templates.length \n    const path           = context.path\n    const value          = context.value\n    const attribute      = this.options.attribute\n\n    if (templates?.length) {\n        transformLiteralByTemplates.call(this, context)\n    } else if (el.tagName=='INPUT') {\n        transformInput.call(this, context)\n    } else if (el.tagName=='BUTTON') {\n        transformButton.call(this, context)\n    } else if (el.tagName=='SELECT') {\n        transformSelect.call(this, context)\n    } else if (el.tagName=='A') {\n        transformAnchor.call(this, context)\n    } else {\n        transformElement.call(this, context)\n    }\n    return context\n}\n\nexport function defaultListTransformer(context) {\n    const el             = context.element\n    const templates      = context.templates\n    const templatesCount = templates.length \n    const path           = context.path\n    const value          = context.value\n    const attribute      = this.options.attribute\n\n    if (!Array.isArray(value)) {\n        console.error('Value is not an array.', el, value)\n    } else if (!templates?.length) {\n        console.error('No templates found in', el)\n    } else {\n        transformArrayByTemplates.call(this, context)\n    }\n    return context\n}\n\nexport function defaultMapTransformer(context) {\n    const el             = context.element\n    const templates      = context.templates\n    const templatesCount = templates.length \n    const path           = context.path\n    const value          = context.value\n    const attribute      = this.options.attribute\n\n    if (typeof value != 'object') {\n        console.error('Value is not an object.', el, value)\n    } else if (!templates?.length) {\n        console.error('No templates found in', el)\n    } else {\n        transformObjectByTemplates.call(this, context)\n    }\n    return context\n}\n\n\n/**\n * Renders an array value by applying templates for each entry\n * Replaces or removes existing DOM children if needed\n * Reuses (doesn't touch) DOM children if template doesn't change\n * FIXME: this doesn't handle situations where there is no matching template\n * this messes up self healing. check transformObjectByTemplates for a better implementation\n */\nexport function transformArrayByTemplates(context) {\n    const el             = context.element\n    const templates      = context.templates\n    const templatesCount = templates.length \n    const path           = context.path\n    const value          = context.value\n    const attribute      = this.options.attribute\n\n    let items = el.querySelectorAll(':scope > ['+attribute+'-key]')\n    // do single merge strategy for now, in future calculate optimal merge strategy from a number\n    // now just do a delete if a key <= last key, insert if a key >= last key\n    let lastKey = 0\n    let skipped = 0\n    context.list  = value\n    for (let item of items) {\n        let currentKey = parseInt(item.getAttribute(attribute+'-key'))\n        if (currentKey>lastKey) {\n            // insert before\n            context.index = lastKey\n            el.insertBefore(this.applyTemplate(context), item)\n        } else if (currentKey<lastKey) {\n            // remove this\n            item.remove()\n        } else {\n            // check that all data-bind params start with current json path or a '#', otherwise replaceChild\n            let bindings = Array.from(item.querySelectorAll(`[${attribute}]`))\n            if (item.matches(`[${attribute}]`)) {\n                bindings.unshift(item)\n            }\n            let needsReplacement = bindings.find(b => {\n                let databind = b.getAttribute(attribute)\n                return (databind.substr(0,5)!=='#root' \n                    && databind.substr(0, path.length)!==path)\n            })\n            if (!needsReplacement) {\n                if (item.$bindTemplate) {\n                    let newTemplate = this.findTemplate(templates, value[lastKey])\n                    if (newTemplate != item.$bindTemplate){\n                        needsReplacement = true\n                        if (!newTemplate) {\n                            skipped++\n                        }\n                    }\n                }\n            }\n            if (needsReplacement) {\n                context.index = lastKey\n                el.replaceChild(this.applyTemplate(context), item)\n            }\n        }\n        lastKey++\n        if (lastKey>=value.length) {\n            break\n        }\n    }\n    items = el.querySelectorAll(':scope > ['+attribute+'-key]')\n    let length = items.length + skipped\n    if (length > value.length) {\n        while (length > value.length) {\n            let child = el.querySelectorAll(':scope > :not(template)')?.[length-1]\n            child?.remove()\n            length--\n        }\n    } else if (length < value.length ) {\n        while (length < value.length) {\n            context.index = length\n            el.appendChild(this.applyTemplate(context))\n            length++\n        }\n    }\n}\n\n/**\n * Renders an object value by applying templates for each entry (Object.entries)\n * Replaces,moves or removes existing DOM children if needed\n * Reuses (doesn't touch) DOM children if template doesn't change\n */\nexport function transformObjectByTemplates(context) {\n    const el             = context.element\n    const templates      = context.templates\n    const templatesCount = templates.length \n    const path           = context.path\n    const value          = context.value\n    const attribute      = this.options.attribute\n    context.list = value\n\n    let items = Array.from(el.querySelectorAll(':scope > ['+attribute+'-key]'))\n    for (let key in context.list) {\n        context.index = key\n        let item = items.shift()\n        if (!item) { // more properties than rendered items\n            el.appendChild(this.applyTemplate(context))\n            continue\n        }\n        if (item.getAttribute[attribute+'-key']!=key) { \n            // next item doesn't match key\n            items.unshift(item) // put item back for next cycle\n            let outOfOrderItem = el.querySelector(':scope > ['+attribute+'-key=\"'+key+'\"]') //FIXME: escape key\n            if (!outOfOrderItem) {\n                let clone = this.applyTemplate(context)\n                if (clone.firstElementChild) {\n                    el.insertBefore(clone, item)\n                }\n                continue // new template doesn't need replacement, so continue \n            } else {\n                el.insertBefore(outOfOrderItem, item)\n                item = outOfOrderItem // check needsreplacement next\n                items = items.filter(i => i!=outOfOrderItem)\n            }\n        }\n        let newTemplate = this.findTemplate(templates, value[key])\n        if (newTemplate != item.$bindTemplate){\n            let clone = this.applyTemplate(context)\n            el.replaceChild(clone, item)\n        }\n    }\n    // clean up remaining items\n    while (items.length) {\n        item = items.shift()\n        item.remove()\n    }\n}\n\nfunction getParentPath(el, attribute) {\n    const parentEl  = el.parentElement?.closest(`[${attribute}-list],[${attribute}-map]`)\n    if (!parentEl) {\n        return '#root'\n    }\n    if (parentEl.hasAttribute(`${attribute}-list`)) {\n        return parentEl.getAttribute(`${attribute}-list`)\n    }\n    return parentEl.getAttribute(`${attribute}-map`)\n}\n\n/**\n * transforms the contents of an html element by rendering\n * a matching template, once.\n * data-bind attributes inside the template use the same\n * parent path as this html element uses\n */\nexport function transformLiteralByTemplates(context) {\n    const el             = context.element\n    const templates      = context.templates\n    const value          = context.value\n    const attribute      = this.options.attribute\n\n    const rendered = el.querySelector(':scope > :not(template)')\n    const template = this.findTemplate(templates, value)\n\n    context.parent = getParentPath(el, attribute)\n    if (rendered) {\n        if (template) {\n            if (rendered?.$bindTemplate != template) {\n                const clone = this.applyTemplate(context)\n                el.replaceChild(clone, rendered)\n            }\n        } else {\n            el.removeChild(rendered)\n        }\n    } else if (template) {\n        const clone = this.applyTemplate(context)\n        el.appendChild(clone)\n    }\n}\n\n/**\n * transforms a single input type\n * for radio/checkbox inputs it only sets the checked attribute to true/false\n * if the value attribute matches the current value\n * for other inputs the value attribute is updated\n * FIXME: handle radio/checkboxes in separate transformer\n */\nexport function transformInput(context) {\n    const el    = context.element\n    const value = context.value\n\n    if (el.type=='checkbox' || el.type=='radio') {\n        if (matchValue(el.value, value)) {\n            el.checked = true\n        } else {\n            el.checked = false\n        }\n    } else if (!matchValue(el.value, value)) {\n        el.value = ''+value\n    }\n}\n\n/**\n * Sets the value of the button, doesn't touch the innerHTML\n */\nexport function transformButton(context) {\n    const el    = context.element\n    const value = context.value\n\n    if (!matchValue(el.value,value)) {\n        el.value = ''+value\n    }\n}\n\n/**\n * Sets the selected attribute of select options\n */\nexport function transformSelect(context) {\n    const el    = context.element\n    const value = context.value\n\n    if (el.multiple) {\n        if (Array.isArray(value)) {\n            for (let option of el.options) {\n                if (value.indexOf(option.value)===false) {\n                    option.selected = false\n                } else {\n                    option.selected = true\n                }\n            }\n        }\n    } else {\n        let option = el.options.find(o => matchValue(o.value,value))\n        if (option) {\n            option.selected = true\n        }\n    }\n}\n\n/**\n * Sets the innerHTML and href attribute of an anchor\n * TODO: support target, title, etc. attributes\n */\nexport function transformAnchor(context) {\n    const el    = context.element\n    const value = context.value\n\n    if (value?.innerHTML && !matchValue(el.innerHTML, value.innerHTML)) {\n        el.innerHTML = ''+value.innerHTML\n    }\n    if (value?.href && !matchValue(el.href,value.href)) {\n        el.href = ''+value.href\n    }    \n}\n\n/**\n * sets the innerHTML of any HTML element\n */\nexport function transformElement(context) {\n    const el    = context.element\n    const value = context.value\n\n    if (!matchValue(el.innerHTML, value)) {\n        if (typeof value=='undefined' || value==null) {\n            el.innerHTML = ''\n        } else {\n            el.innerHTML = ''+value\n        }\n    }\n}", "import { routes } from './route.mjs'\nimport { commands } from './command.mjs'\nimport { actions } from './action.mjs'\nimport { keys } from './key.mjs'\nimport { signal } from './state.mjs'\nimport { bind } from './bind.mjs'\n\nclass SimplyApp {\n\tconstructor(options={}) {\n\t\tthis.container = options.container || document.body\n\t\tif (!options.state) {\n\t\t\toptions.state = {}\n\t\t}\n\t\tthis.state = signal(options.state)\n\t\tif (options.commands) {\n\t\t\tthis.commands = commands({ app: this, container: this.container, commands: options.commands})\n\t\t}\n\t\tif (options.keys) {\n\t\t\tthis.keys = keys({ app: this, keys: options.keys })\n\t\t}\n\t\tif (options.routes) {\n\t\t\tthis.routes = routes({ app: this, routes: options.routes})\n\t\t}\n\t\tif (options.actions) {\n\t\t\tthis.actions = actions({app: this, actions: options.actions})\n\t\t}\n\t\tlet bindOptions = { container: this.container, root: this.state }\n\t\tif (options.defaultTransformers) {\n\t\t\tbindOptions.defaultTransformers = options.defaultTransformers\n\t\t}\n\t\tif (options.transformers) {\n\t\t\tbindOptions.transformers = options.transformers\n\t\t}\n\t\tthis.bind = bind(bindOptions)\n\t}\n}\n\nexport function app(options={}) {\n\treturn new SimplyApp(options)\n}"],
  "mappings": "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",
  "names": ["routes", "options", "SimplyRoute", "parseRoutes", "path", "args", "matches", "getPath", "route", "params", "key", "i", "action", "routeRe", "getRegexpFromRoute", "result", "callback", "evt", "link", "getURL", "listener", "root", "routeInfo", "paths", "matchParams", "SimplyCommands", "options", "defaultHandlers", "commandHandler", "evt", "command", "getCommand", "commands", "handlers", "el", "handler", "values", "option", "data", "input", "actions", "options", "actionHandler", "target", "property", "SimplyKeys", "options", "keyHandler", "e", "selectedKeyboard", "key", "keys", "iterate", "signalHandler", "target", "property", "receiver", "value", "notifyGet", "args", "l", "result", "notifySet", "makeContext", "signal", "current", "signals", "descriptor", "v", "batchedListeners", "batchMode", "self", "context", "listeners", "change", "propListeners", "getListeners", "listener", "addContext", "currentEffect", "computeStack", "clearContext", "prop", "currentCompute", "setListeners", "listenersMap", "computeMap", "compute", "connectedSignals", "clearListeners", "s", "effectStack", "effectMap", "signalStack", "destroy", "connectedSignal", "computeEffect", "effectMap", "clearListeners", "fn", "signals", "throttledEffect", "fn", "throttleTime", "effectStack", "f", "connectedSignal", "signals", "signal", "throttled", "hasChange", "computeEffect", "signalStack", "s", "clearListeners", "computeStack", "result", "SimplyBind", "options", "defaultOptions", "defaultFieldTransformer", "defaultListTransformer", "defaultMapTransformer", "attribute", "bindAttributes", "bindSelector", "getBindingAttribute", "el", "foundAttribute", "attr", "render", "throttledEffect", "context", "getValueByPath", "runTransformers", "transformers", "t", "next", "transformer", "applyBindings", "bindings", "bindingEl", "updateBindings", "changes", "selector", "change", "node", "path", "templates", "list", "index", "parent", "value", "template", "result", "clone", "attributes", "binding", "bind", "templateMatches", "currentItem", "strItem", "matches", "rel", "replacement", "destroy", "matchValue", "a", "b", "root", "parts", "curr", "part", "prevPart", "templatesCount", "transformLiteralByTemplates", "transformInput", "transformButton", "transformSelect", "transformAnchor", "transformElement", "transformArrayByTemplates", "transformObjectByTemplates", "items", "lastKey", "skipped", "item", "currentKey", "needsReplacement", "databind", "newTemplate", "length", "key", "outOfOrderItem", "i", "getParentPath", "parentEl", "rendered", "option", "o", "SimplyApp", "options", "signal", "commands", "keys", "routes", "actions", "bindOptions", "bind", "app"]
}
