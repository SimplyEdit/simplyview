{
  "version": 3,
  "sources": ["../src/route.mjs", "../src/command.mjs", "../src/action.mjs", "../src/key.mjs", "../src/state.mjs", "../src/bind.mjs", "../src/app.mjs"],
  "sourcesContent": ["export function routes(options) {\n\treturn new SimplyRoute(options)\n}\n\nclass SimplyRoute {\n\tconstructor(options={}) {\n\t\tthis.root = options.root || '/'\n        this.app = options.app\n\t\tthis.clear()\n\t\tif (options.routes) {\n\t\t\tthis.load(options.routes)\n\t\t}\n\t}\n\n\tload(routes) {\n\t\tparseRoutes(routes, this.routeInfo)\n\t}\n\n\tclear() {\n\t\tthis.routeInfo = []\n\t\tthis.listeners = {\n\t\t\tmatch: {},\n\t\t\tcall: {},\n\t\t\tfinish: {}\n\t\t}\n\t}\n\n\tmatch(path, options) {\n\t\tlet args = {\n            path,\n            options\n        }\n        args = this.runListeners('match',args)\n        path = args.path ? args.path : path;\n\n        let matches;\n        if (!path) {\n            if (this.match(document.location.pathname+document.location.hash)) {\n                return true;\n            } else {\n                return this.match(document.location.pathname);\n            }\n        }\n        path = getPath(path);\n        for ( let route of this.routeInfo) {\n            matches = route.match.exec(path)\n            if (matches && matches.length) {\n                var params = {};\n                route.params.forEach((key, i) => {\n                    if (key=='*') {\n                        key = 'remainder'\n                    }\n                    params[key] = matches[i+1]\n                })\n                Object.assign(params, options)\n                args.route = route\n                args.params = params\n                args = this.runListeners('call', args)\n                params = args.params ? args.params : params\n                args.result = route.action.call(route, params)\n                this.runListeners('finish', args)\n                return args.result\n            }\n        }\n        if (path && path[path.length-1]!='/') {\n        \treturn this.match(path+'/', options)\n        }\n        return false\n\t}\n\n\trunListeners(action, params) {\n        if (!Object.keys(this.listeners[action])) {\n            return\n        }\n        Object.keys(this.listeners[action]).forEach((route) => {\n            var routeRe = getRegexpFromRoute(route);\n            if (routeRe.exec(params.path)) {\n                var result;\n                for (let callback of this.listeners[action][route]) {\n                    result = callback.call(this.app, params)\n                    if (result) {\n                        params = result\n                    }\n                }\n            }\n        })\n        return params\n    }\n\n    handleEvents() {\n        globalThis.addEventListener('popstate', () => {\n            if (this.match(getPath(document.location.pathname + document.location.hash, this.root)) === false) {\n                this.match(getPath(document.location.pathname, this.root))\n            }\n        })\n        globalThis.document.addEventListener('click', (evt) => {\n\t        if (evt.ctrlKey) {\n\t            return;\n\t        }\n\t        if (evt.which != 1) {\n\t            return; // not a 'left' mouse click\n\t        }\n\t        var link = evt.target;\n\t        while (link && link.tagName!='A') {\n\t            link = link.parentElement;\n\t        }\n\t        if (link \n\t            && link.pathname \n\t            && link.hostname==globalThis.location.hostname \n\t            && !link.link\n\t            && !link.dataset.simplyCommand\n\t        ) {\n\t            let path = getPath(link.pathname+link.hash, this.root);\n\t            if ( !this.has(path) ) {\n\t                path = getPath(link.pathname, this.root);\n\t            }\n\t            if ( this.has(path) ) {\n\t                let params = this.runListeners('goto', { path: path});\n\t                if (params.path) {\n\t                    this.goto(params.path);\n\t                }\n\t                evt.preventDefault();\n\t                return false;\n\t            }\n\t        }\n\t    })\n    }\n\n    goto(path) {\n        history.pushState({},'',getURL(path))\n        return this.match(path)\n    }\n\n    has(path) {\n    \tpath = getPath(path, this.root)\n    \tfor (let route of this.routeInfo) {\n            var matches = route.match.exec(path)\n            if (matches && matches.length) {\n                return true\n            }\n        }\n        return false\n    }\n\n    addListener(action, route, callback) {\n        if (['goto','match','call','finish'].indexOf(action)==-1) {\n            throw new Error('Unknown action '+action)\n        }\n        if (!this.listeners[action][route]) {\n            this.listeners[action][route] = []\n        }\n        this.listeners[action][route].push(callback)\n    }\n\n    removeListener(action, route, callback) {\n        if (['match','call','finish'].indexOf(action)==-1) {\n            throw new Error('Unknown action '+action)\n        }\n        if (!this.listeners[action][route]) {\n            return\n        }\n        this.listeners[action][route] = this.listeners[action][route].filter((listener) => {\n            return listener != callback\n        })\n    }\n\n    init(options) {\n    \tif (options.root) {\n    \t\tthis.root = options.root\n    \t}\n    }\n}\n\nfunction getPath(path, root='/') {\n    if (path.substring(0,root.length)==root\n        ||\n        ( root[root.length-1]=='/' \n            && path.length==(root.length-1)\n            && path == root.substring(0,path.length)\n        )\n    ) {\n        path = path.substring(root.length)\n    }\n    if (path[0]!='/' && path[0]!='#') {\n        path = '/'+path\n    }\n    return path\n}\n\nfunction getURL(path, root) {\n    path = getPath(path, root)\n    if (root[root.length-1]==='/' && path[0]==='/') {\n        path = path.substring(1)\n    }\n    return root + path;\n}\n\nfunction getRegexpFromRoute(route) {\n    return new RegExp('^'+route.replace(/:\\w+/g, '([^/]+)').replace(/:\\*/, '(.*)'));\n}\n\nfunction parseRoutes(routes) {\n    let routeInfo = []\n    const paths = Object.keys(routes)\n    const matchParams = /:(\\w+|\\*)/g\n    for (let path of paths) {\n        let matches = []\n        let params  = []\n        do {\n            matches = matchParams.exec(path)\n            if (matches) {\n                params.push(matches[1])\n            }\n        } while(matches)\n        routeInfo.push({\n            match:  getRegexpFromRoute(path),\n            params: params,\n            action: routes[path]\n        })\n    }\n    return routeInfo\n}\n", "class SimplyCommands {\n\tconstructor(options={}) {\n\t\tif (!options.app) {\n\t\t\toptions.app = {}\n\t\t}\n\t\tif (!options.app.container) {\n\t\t\toptions.app.container = document.body\n\t\t}\n\t\tthis.app = options.app\n\t\tthis.handlers = options.handlers || defaultHandlers\n\t\tthis.commands = options.commands || {}\n\n\t\tconst commandHandler = (evt) => {\n\t\t\tconst command = getCommand(evt, this.handlers)\n\t\t\tif (!command) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (!this.commands[command.name]) {\n                console.error('simply.command: undefined command '+command.name, command.source);\n                return\n\t\t\t}\n\t\t\tthis.commands[command.name].call(this.app, command.source, command.value)\n\t\t}\n\n        function stop(fn) {\n            return (evt) => {\n                fn(evt)\n                evt.preventDefault()\n                evt.stopPropagation()\n                return false                \n            }\n        }\n\n        this.app.container.addEventListener('click', stop(commandHandler))\n        this.app.container.addEventListener('submit', stop(commandHandler))\n        this.app.container.addEventListener('change', commandHandler)\n        this.app.container.addEventListener('input', commandHandler)\n\t}\n}\n\nexport function commands(options={}) {\n\treturn new SimplyCommands(options)\n}\n\nfunction getCommand(evt, handlers) {\n    var el = evt.target.closest('[data-simply-command]')\n    if (el) {\n        for (var i=handlers.length-1; i>=0; i--) {\n            if (el.matches(handlers[i].match)) {\n                if (handlers[i].check(el, evt)) {\n                    return {\n                        name:   el.dataset.simplyCommand,\n                        source: el,\n                        value:  handlers[i].get(el)\n                    }\n                }\n            }\n        }\n    }\n    return null;\n}\n\nconst defaultHandlers = [\n    {\n        match: 'input,select,textarea',\n        get: function(el) {\n            if (el.tagName==='SELECT' && el.multiple) {\n                let values = []\n                for (let option of el.options) {\n                    if (option.selected) {\n                        values.push(option.value)\n                    }\n                }\n                return values\n            }\n            return el.dataset.simplyValue || el.value\n        },\n        check: function(el, evt) {\n            return evt.type=='change' || (el.dataset.simplyImmediate && evt.type=='input')\n        }\n    },\n    {\n        match: 'a,button',\n        get: function(el) {\n            return el.dataset.simplyValue || el.href || el.value\n        },\n        check: function(el,evt) {\n            return evt.type=='click' && evt.ctrlKey==false && evt.button==0\n        }\n    },\n    {\n        match: 'form',\n        get: function(el) {\n            let data = {}\n            for (let input of Array.from(el.elements)) {\n                if (input.tagName=='INPUT' \n                    && (input.type=='checkbox' || input.type=='radio')\n                ) {\n                    if (!input.checked) {\n                        return;\n                    }\n                }\n                if (data[input.name] && !Array.isArray(data[input.name])) {\n                    data[input.name] = [data[input.name]]\n                }\n                if (Array.isArray(data[input.name])) {\n                    data[input.name].push(input.value)\n                } else {\n                    data[input.name] = input.value\n                }\n            }\n            return data\n        },\n        check: function(el,evt) {\n            return evt.type=='submit'\n        }\n    },\n    {\n    \tmatch: '*',\n        get: function(el) {\n            return el.dataset.simplyValue\n        },\n        check: function(el, evt) {\n            return evt.type=='click' && evt.ctrlKey==false && evt.button==0\n        }\n    }\n]", "class SimplyActions {\n\tconstructor(options) {\n        this.app = options.app\n        \n\t\tconst actionHandler = {\n\t\t\tget: (target, property) => {\n\t\t\t\treturn target[property].bind(this.app)\n\t\t\t}\n\t\t}\n\n\t\tthis.actions = new Proxy({}, actionHandler)\n\t\tObject.assign(this.actions, options.actions)\n\t}\n}\n\nexport function actions(options) {\n\treturn new SimplyActions(options)\n}", "class SimplyKeys {\n\tconstructor(options = {} ) {\n\t\tif (!options.app) {\n\t\t\toptions.app = {}\n\t\t}\n\t\tif (!options.app.container) {\n\t\t\toptions.app.container = document.body\n\t\t}\n\t\tthis.app = options.app\n\t\tthis.app.container.addEventListener('keydown', keyHandler(this.keys))\n\t}\n}\n\nexport function keys(options={}) {\n\treturn new SimplyKeys(options)\n}\n\nfunction keyHandler(keys) {\n\treturn (e) => {\n\t\tif (e.isComposing || e.keyCode === 229) {\n\t\t    return;\n\t\t}\n\t\tif (e.defaultPrevented) {\n\t\t    return;\n\t\t}\n\t\tif (!e.target) {\n\t\t    return;\n\t\t}\n\n\t\tlet selectedKeyboard = 'default';\n\t\tif (e.target.closest('[data-simply-keyboard]')) {\n\t\t    selectedKeyboard = e.target.closest('[data-simply-keyboard]').dataset.simplyKeyboard;\n\t\t}\n\t\tlet key = '';\n\t\tif (e.ctrlKey && e.keyCode!=17) {\n\t\t    key+='Control+';\n\t\t}\n\t\tif (e.metaKey && e.keyCode!=224) {\n\t\t    key+='Meta+';\n\t\t}\n\t\tif (e.altKey && e.keyCode!=18) {\n\t\t    key+='Alt+';\n\t\t}\n\t\tif (e.shiftKey && e.keyCode!=16) {\n\t\t    key+='Shift+';\n\t\t}\n\t\tkey+=e.key;\n\n\t\tif (keys[selectedKeyboard] && keys[selectedKeyboard][key]) {\n\t\t    let keyboard = keys[selectedKeyboard]\n\t\t    keyboard.app = keys.app;\n\t\t    keyboard[key].call(keys.app,e);\n\t\t}\n\t}\n}", "const source = Symbol('source')\nconst iterate = Symbol('iterate')\n\nconst signalHandler = {\n    get: (target, property, receiver) => {\n        if (property===source) {\n            return target // don't notifyGet here, this is only called by set\n        }\n        const value = target?.[property] // Reflect.get fails on a Set.\n        notifyGet(receiver, property)\n        if (typeof value === 'function') {\n            if (Array.isArray(target)) {\n                return (...args) => {\n                    let l = target.length\n                    // by binding the function to the receiver\n                    // all accesses in the function will be trapped\n                    // by the Proxy, so get/set/delete is all handled\n                    let result = value.apply(receiver, args)\n                    if (l != target.length) {\n                        notifySet(receiver,  makeContext('length', { was: l, now: target.length }) )\n                    }\n                    return result\n                }\n            } else if (target instanceof Set || target instanceof Map) {\n                return (...args) => {\n                    // node doesn't allow you to call set/map functions\n                    // bound to the receiver.. so using target instead\n                    // there are no properties to update anyway, except for size\n                    let s = target.size\n                    let result = value.apply(target, args)\n                    if (s != target.size) {\n                        notifySet(receiver, makeContext( 'size', { was: s, now: target.size }) )\n                    }\n                    // there is no efficient way to see if the function called\n                    // has actually changed the Set/Map, but by assuming the\n                    // 'setter' functions will change the results of the\n                    // 'getter' functions, effects should update correctly\n                    if (['set','add','clear','delete'].includes(property)) {\n                        notifySet(receiver, makeContext( { entries: {}, forEach: {}, has: {}, keys: {}, values: {}, [Symbol.iterator]: {} } ) )\n                    }\n                    return result\n                }\n            } else {\n                // support custom classes, hopefully\n                return value.bind(receiver)\n            }\n        }\n        if (value && typeof value == 'object') {\n            //NOTE: get now returns a signal, set doesn't 'unsignal' the value set\n            return signal(value)\n        }\n        return value\n    },\n    set: (target, property, value, receiver) => {\n        value = value?.[source] || value // unwraps signal\n        let current = target[property]\n        if (current!==value) {\n            target[property] = value\n            notifySet(receiver, makeContext(property, { was: current, now: value } ) )\n        }\n        if (typeof current === 'undefined') {\n            notifySet(receiver, makeContext(iterate, {}))\n        }\n        return true\n    },\n    has: (target, property) => { // receiver is not part of the has() call\n        let receiver = signals.get(target) // so retrieve it here\n        if (receiver) {\n            notifyGet(receiver, property)\n        }\n        return Object.hasOwn(target, property)\n    },\n    deleteProperty: (target, property) => {\n        if (typeof target[property] !== 'undefined') {\n            let current = target[property]\n            delete target[property]\n            let receiver = signals.get(target) // receiver is not part of the trap arguments, so retrieve it here\n            notifySet(receiver, makeContext(property,{ delete: true, was: current }))\n        }\n        return true\n    },\n    defineProperty: (target, property, descriptor) => {\n        if (typeof target[property] === 'undefined') {\n            let receiver = signals.get(target) // receiver is not part of the trap arguments, so retrieve it here\n            notifySet(receiver, makeContext(iterate, {}))\n        }\n        return Object.defineProperty(target, property, descriptor)\n    },\n    ownKeys: (target) => {\n        let receiver = signals.get(target) // receiver is not part of the trap arguments, so retrieve it here\n        notifyGet(receiver, iterate)\n        return Reflect.ownKeys(target)\n    }\n\n}\n\n/**\n * Keeps track of the return signal for an update function, as well\n * as signals connected to other objects. \n * Makes sure that a given object or function always uses the same\n * signal\n */\nconst signals = new WeakMap()\n\n/**\n * Creates a new signal proxy of the given object, that intercepts get/has and set/delete\n * to allow reactive functions to be triggered when signal values change.\n */\nexport function signal(v) {\n    if (!signals.has(v)) {\n        signals.set(v, new Proxy(v, signalHandler))\n    }\n    return signals.get(v)\n}\n\nlet batchedListeners = new Set()\nlet batchMode = 0\n/**\n * Called when a signal changes a property (set/delete)\n * Triggers any reactor function that depends on this signal\n * to re-compute its values\n */\nfunction notifySet(self, context={}) {\n    let listeners = []\n    context.forEach((change, property) => {\n        let propListeners = getListeners(self, property)\n        if (propListeners?.length) {\n            for (let listener of propListeners) {\n                addContext(listener, makeContext(property,change))\n            }\n            listeners = listeners.concat(propListeners)\n        }\n    })\n    listeners = new Set(listeners.filter(Boolean))\n    if (listeners) {\n        if (batchMode) {\n            batchedListeners = batchedListeners.union(listeners)\n        } else {\n            const currentEffect = computeStack[computeStack.length-1]\n            for (let listener of Array.from(listeners)) {\n                if (listener!=currentEffect && listener?.needsUpdate) {\n                    listener()\n                }\n                clearContext(listener)\n            }\n        }\n    }\n}\n\nfunction makeContext(property, change) {\n    let context = new Map()\n    if (typeof property === 'object') {\n        for (let prop in property) {\n            context.set(prop, property[prop])\n        }\n    } else {\n        context.set(property, change)\n    }\n    return context\n}\n\nfunction addContext(listener, context) {\n    if (!listener.context) {\n        listener.context = context\n    } else {\n        context.forEach((change,property)=> {\n            listener.context.set(property, change) // TODO: merge change if needed\n        })\n    }\n    listener.needsUpdate = true\n}\n\nfunction clearContext(listener) {\n    delete listener.context\n    delete listener.needsUpdate\n}\n\n/**\n * Called when a signal property is accessed. If this happens\n * inside a reactor function--computeStack is not empty--\n * then it adds the current reactor (top of this stack) to its\n * listeners. These are later called if this property changes\n */\nfunction notifyGet(self, property) {\n    let currentCompute = computeStack[computeStack.length-1]\n    if (currentCompute) {\n        // get was part of a react() function, so add it\n        setListeners(self, property, currentCompute)\n    }\n}\n\n/**\n * Keeps track of which update() functions are dependent on which\n * signal objects and which properties. Maps signals to update fns\n */\nconst listenersMap = new WeakMap()\n\n/**\n * Keeps track of which signals and properties are linked to which\n * update functions. Maps update functions and properties to signals\n */\nconst computeMap = new WeakMap()\n\n/**\n * Returns the update functions for a given signal and property\n */\nfunction getListeners(self, property) {\n    let listeners = listenersMap.get(self)\n    return listeners ? Array.from(listeners.get(property) || []) : []\n}\n\n/**\n * Adds an update function (compute) to the list of listeners on\n * the given signal (self) and property\n */\nfunction setListeners(self, property, compute) {\n    if (!listenersMap.has(self)) {\n        listenersMap.set(self, new Map())\n    }\n    let listeners = listenersMap.get(self)\n    if (!listeners.has(property)) {\n        listeners.set(property, new Set())\n    }\n    listeners.get(property).add(compute)\n\n    if (!computeMap.has(compute)) {\n        computeMap.set(compute, new Map())\n    }\n    let connectedSignals = computeMap.get(compute)\n    if (!connectedSignals.has(property)) {\n        connectedSignals.set(property, new Set)\n    }\n    connectedSignals.get(property).add(self)\n}\n\n/**\n * Removes alle listeners that trigger the given reactor function (compute)\n * This happens when a reactor is called, so that it can set new listeners\n * based on the current call (code path)\n */\nfunction clearListeners(compute) {\n    let connectedSignals = computeMap.get(compute)\n    if (connectedSignals) {\n        connectedSignals.forEach(property => {\n            property.forEach(s => {\n                let listeners = listenersMap.get(s)\n                if (listeners.has(property)) {\n                    listeners.get(property).delete(compute)\n                }\n            })\n        })\n    }\n}\n\n/**\n * The top most entry is the currently running update function, used\n * to automatically record signals used in an update function.\n */\nlet computeStack = []\n\n/**\n * Used for cycle detection: effectStack contains all running effect\n * functions. If the same function appears twice in this stack, there\n * is a recursive update call, which would cause an infinite loop.\n */\nconst effectStack = []\n\nconst effectMap = new WeakMap()\n/**\n * Used for cycle detection: signalStack contains all used signals. \n * If the same signal appears more than once, there is a cyclical \n * dependency between signals, which would cause an infinite loop.\n */\nconst signalStack = []\n\n/**\n * Runs the given function at once, and then whenever a signal changes that\n * is used by the given function (or at least signals used in the previous run).\n */\nexport function effect(fn) {\n    if (effectStack.findIndex(f => fn==f)!==-1) {\n        throw new Error('Recursive update() call', {cause:fn})\n    }\n    effectStack.push(fn)\n\n    let connectedSignal = signals.get(fn)\n    if (!connectedSignal) {\n        connectedSignal = signal({\n            current: null\n        })\n        signals.set(fn, connectedSignal)\n    }\n\n    // this is the function that is called automatically\n    // whenever a signal dependency changes\n    const computeEffect = function computeEffect() {\n        if (signalStack.findIndex(s => s==connectedSignal)!==-1) {\n            throw new Error('Cyclical dependency in update() call', { cause: fn})\n        }\n        // remove all dependencies (signals) from previous runs \n        clearListeners(computeEffect)\n        // record new dependencies on this run\n        computeStack.push(computeEffect)\n        // prevent recursion\n        signalStack.push(connectedSignal)\n        // call the actual update function\n        let result\n        try {\n            result = fn(computeEffect, computeStack, signalStack)\n        } finally {\n            // stop recording dependencies\n            computeStack.pop()\n            // stop the recursion prevention\n            signalStack.pop()\n            if (result instanceof Promise) {\n                result.then((result) => {\n                    connectedSignal.current = result\n                })\n            } else {\n                connectedSignal.current = result\n            }\n        }\n    }\n    computeEffect.fn = fn\n    effectMap.set(connectedSignal, computeEffect)\n\n    // run the computEffect immediately upon creation\n    computeEffect()\n    return connectedSignal\n}\n\n\nexport function destroy(connectedSignal) {\n    // find the computeEffect associated with this signal\n    const computeEffect = effectMap.get(connectedSignal)?.deref()\n    if (!computeEffect) {\n        return\n    }\n\n    // remove all listeners for this effect\n    clearListeners(computeEffect)\n\n    // remove all references to connectedSignal\n    let fn = computeEffect.fn\n    signals.remove(fn)\n\n    effectMap.delete(connectedSignal)\n\n    // if no other references to connectedSignal exist, it will be garbage collected\n}\n\n/**\n * Inside a batch() call, any changes to signals do not trigger effects\n * immediately. Instead, immediately after finishing the batch() call,\n * these effects will be called. Effects that are triggered by multiple\n * signals are called only once.\n * @param Function fn batch() calls this function immediately\n * @result mixed the result of the fn() function call\n */\nexport function batch(fn) {\n    batchMode++\n    let result\n    try {\n        result = fn()\n    } finally {\n        if (result instanceof Promise) {\n            result.then(() => {\n                batchMode--\n                if (!batchMode) {\n                    runBatchedListeners()\n                }\n            })\n        } else {\n            batchMode--\n            if (!batchMode) {\n                runBatchedListeners()\n            }\n        }\n    }\n    return result\n}\n\nfunction runBatchedListeners() {\n    let copyBatchedListeners = Array.from(batchedListeners)\n    batchedListeners = new Set()\n    const currentEffect = computeStack[computeStack.length-1]\n    for (let listener of copyBatchedListeners) {\n        if (listener!=currentEffect && listener?.needsUpdate) {\n            listener()\n        }\n        clearContext(listener)\n    }\n}\n\n/**\n * A throttledEffect is run immediately once. And then only once\n * per throttleTime (in ms).\n * @param Function fn the effect function to run whenever a signal changes\n * @param int throttleTime in ms\n * @returns signal with the result of the effect function fn\n */\nexport function throttledEffect(fn, throttleTime) {\n    if (effectStack.findIndex(f => fn==f)!==-1) {\n        throw new Error('Recursive update() call', {cause:fn})\n    }\n    effectStack.push(fn)\n\n    let connectedSignal = signals.get(fn)\n    if (!connectedSignal) {\n        connectedSignal = signal({\n            current: null\n        })\n        signals.set(fn, connectedSignal)\n    }\n\n    let throttled = false\n    let hasChange = true\n    // this is the function that is called automatically\n    // whenever a signal dependency changes\n    const computeEffect = function computeEffect() {\n        if (signalStack.findIndex(s => s==connectedSignal)!==-1) {\n            throw new Error('Cyclical dependency in update() call', { cause: fn})\n        }\n        if (throttled && throttled>Date.now()) {\n            hasChange = true\n            return\n        }\n        // remove all dependencies (signals) from previous runs \n        clearListeners(computeEffect)\n        // record new dependencies on this run\n        computeStack.push(computeEffect)\n        // prevent recursion\n        signalStack.push(connectedSignal)\n        // call the actual update function\n        let result\n        try {\n            result = fn(computeEffect, computeStack, signalStack)\n        } finally {\n            hasChange = false\n            // stop recording dependencies\n            computeStack.pop()\n            // stop the recursion prevention\n            signalStack.pop()\n            if (result instanceof Promise) {\n                result.then((result) => {\n                    connectedSignal.current = result\n                })\n            } else {\n                connectedSignal.current = result\n            }\n        }\n        throttled = Date.now()+throttleTime\n        globalThis.setTimeout(() => {\n            if (hasChange) {\n                computeEffect()\n            }\n        }, throttleTime)\n    }\n    // run the computEffect immediately upon creation\n    computeEffect()\n    return connectedSignal\n}\n\n// refactor: Class clock() with an effect() method\n// keep track of effects per clock, and add clock property to the effect function\n// on notifySet add clock.effects to clock.needsUpdate list\n// on clock.tick() (or clock.time++) run only the clock.needsUpdate effects \n// (first create a copy and reset clock.needsUpdate, then run effects)\nexport function clockEffect(fn, clock) {\n    let connectedSignal = signals.get(fn)\n    if (!connectedSignal) {\n        connectedSignal = signal({\n            current: null\n        })\n        signals.set(fn, connectedSignal)\n    }\n\n    let lastTick = -1 // clock.time should start at 0 or larger\n    let hasChanged = true // make sure the first run goes through\n    // this is the function that is called automatically\n    // whenever a signal dependency changes\n    const computeEffect = function computeEffect() {\n        if (lastTick < clock.time) {\n            if (hasChanged) {\n                // remove all dependencies (signals) from previous runs \n                clearListeners(computeEffect)\n                // record new dependencies on this run\n                computeStack.push(computeEffect)\n                // make sure the clock.time signal is a dependency\n                lastTick = clock.time\n                // call the actual update function\n                let result \n                try {\n                    result = fn(computeEffect, computeStack)\n                } finally {\n                    // stop recording dependencies\n                    computeStack.pop()\n                    if (result instanceof Promise) {\n                        result.then((result) => {\n                            connectedSignal.current = result\n                        })\n                    } else {\n                        connectedSignal.current = result\n                    }\n                    hasChanged = false\n                }\n            } else {\n                lastTick = clock.time\n            }\n        } else {\n            hasChanged = true\n        }\n    }\n    // run the computEffect immediately upon creation\n    computeEffect()\n    return connectedSignal\n}\n\nexport function untracked(fn) {\n    const remember = computeStack.slice()\n    computeStack = []\n    try {\n        return fn()\n    } finally {\n        computeStack = remember\n    }\n}", "import { throttledEffect } from './state.mjs'\n\nclass SimplyBind {\n    constructor(options) {\n        const defaultOptions = {\n            container: document.body,\n            attribute: 'data-bind',\n            transformers: [],\n            defaultTransformers: [defaultTransformer]\n        }\n        if (!options?.root) {\n            throw new Error('bind needs at least options.root set')\n        }\n        this.options = Object.assign({}, defaultOptions, options)\n\n        const attribute = this.options.attribute\n\n        // sets up the effect that updates the element if its\n        // data binding value changes\n        const render = (el) => {\n            throttledEffect(() => {\n                const context = {\n                    templates: el.querySelectorAll(':scope > template'),\n                    path: this.getBindingPath(el)\n                }\n                context.value = getValueByPath(this.options.root, context.path)\n                context.element = el\n                runTransformers(context)\n            }, 100)\n        }\n\n        // finds and runs applicable transformers\n        // creates a stack of transformers, calls the topmost\n        // each transformer can opt to call the next or not\n        // transformers should return the context object (possibly altered)\n        const runTransformers = (context) => {\n            let transformers = this.options.defaultTransformers || []\n            if (context.element.dataset.transform) {\n                context.element.dataset.transform.split(' ').filter(Boolean).forEach(t => {\n                    if (this.options.transformers[t]) {\n                        transformers.push(this.options.transformers[t])\n                    } else {\n                        console.warn('No transformer with name '+t+' configured', {cause:context.element})\n                    }\n                })\n            }\n            let next\n            for (let transformer of transformers) {\n                next = ((next, transformer) => {\n                    return (context) => {\n                        return transformer.call(this, context, next)\n                    }\n                })(next, transformer)\n            }\n            next(context)\n        }\n\n        // given a set of elements with data bind attribute\n        // this renders each of those elements\n        const applyBindings = (bindings) => {\n            for (let bindingEl of bindings) {\n                render(bindingEl)\n            }\n        }\n\n        // this handles the mutation observer changes\n        // if any element is added, and has a data bind attribute\n        // it applies that data binding\n        const updateBindings = (changes) => {\n            for (const change of changes) {\n                if (change.type==\"childList\" && change.addedNodes) {\n                    for (let node of change.addedNodes) {\n                        if (node instanceof HTMLElement) {\n                            let bindings = Array.from(node.querySelectorAll(`[${attribute}]`))\n                            if (node.matches(`[${attribute}]`)) {\n                                bindings.unshift(node)\n                            }\n                            if (bindings.length) {\n                                applyBindings(bindings)\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // this responds to elements getting added to the dom\n        // and if any have data bind attributes, it applies those bindings\n        const observer = new MutationObserver((changes) => {\n            updateBindings(changes)\n        })\n\n        observer.observe(options.container, {\n            subtree: true,\n            childList: true\n        })\n\n        // this finds elements with data binding attributes and applies those bindings\n        // must come after setting up the observer, or included templates\n        // won't trigger their own bindings\n        const bindings = this.options.container.querySelectorAll('['+this.options.attribute+']:not(template)')\n        if (bindings.length) {\n            applyBindings(bindings)\n        }\n\n    }\n\n    /**\n     * Finds the first matching template and creates a new DocumentFragment\n     * with the correct data bind attributes in it (prepends the current path)\n     */\n    applyTemplate(path, templates, list, index) {\n        let template = this.findTemplate(templates, list[index])\n        if (!template) {\n            let result = new DocumentFragment()\n            result.innerHTML = '<!-- no matching template -->'\n            return result\n        }\n        let clone = template.content.cloneNode(true)\n        if (!clone.children?.length) {\n            throw new Error('template must contain a single html element', { cause: template })\n        }\n        if (clone.children.length>1) {\n            throw new Error('template must contain a single root node', { cause: template })\n        }\n        const bindings = clone.querySelectorAll('['+this.options.attribute+']')\n        const attribute = this.options.attribute\n        for (let binding of bindings) {\n            const bind = binding.getAttribute(attribute)\n            if (bind.substring(0, '#root.'.length)=='#root.') {\n                binding.setAttribute(attribute, bind.substring('#root.'.length))\n            } else if (bind=='#value') {\n                binding.setAttribute(attribute, path+'.'+index)\n            } else {\n                binding.setAttribute(attribute, path+'.'+index+'.'+bind)\n            }\n        }\n        clone.children[0].setAttribute(attribute+'-key',index)\n        // keep track of the used template, so if that changes, the \n        // item can be updated\n        clone.children[0].$bindTemplate = template\n        return clone\n    }\n\n    getBindingPath(el) {\n        return el.getAttribute(this.options.attribute)\n    }\n\n    /**\n     * Finds the first template from an array of templates that\n     * matches the given value. \n     */\n    findTemplate(templates, value) {\n        const templateMatches = t => {\n            let path = this.getBindingPath(t)\n            if (!path) {\n                return t\n            }\n            let currentItem\n            if (path.substr(0,6)=='#root.') {\n                currentItem = getValueByPath(this.options.root, path)\n            } else {\n                currentItem = getValueByPath(value, path)\n            }\n            const strItem = ''+currentItem\n            let matches = t.getAttribute(this.options.attribute+'-matches')\n            if (matches) {\n                if (matches==='#empty' && !currentItem) {\n                    return t\n                } else if (matches==='#notempty' && currentItem) {\n                    return t\n                }\n                if (strItem.match(matches)) {\n                    return t\n                }\n            }\n            if (!matches) {\n                if (currentItem) {\n                    return t\n                }\n            }\n        };\n        let template = Array.from(templates).find(templateMatches)\n        let rel = template?.getAttribute('rel')\n        if (rel) {\n            let replacement = document.querySelector('template#'+rel)\n            if (!replacement) {\n                throw new Error('Could not find template with id '+rel)\n            }\n            template = replacement\n        }\n        return template\n    }\n\n}\n\n/**\n * Returns a new instance of SimplyBind. This is the normal start\n * of a data bind flow\n */\nexport function bind(options)\n{\n    return new SimplyBind(options)\n}\n\n/**\n * Returns true if a matches b, either by having the\n * same string value, or matching string #empty against a falsy value\n */\nexport function matchValue(a,b) {\n    if (a=='#empty' && !b) {\n        return true\n    }\n    if (b=='#empty' && !a) {\n        return true\n    }\n    if (''+a == ''+b) {\n        return true\n    }\n    return false\n}\n\n/**\n * Returns the value by walking the given path\n * as a json pointer, starting at root\n * if you have a property with a '.' in its name\n * urlencode the '.', e.g: %46\n */\nexport function getValueByPath(root, path)\n{\n    let parts = path.split('.');\n    let curr = root;\n    let part, prevPart;\n    while (parts.length && curr) {\n        part = parts.shift()\n        if (part=='#key') {\n            return prevPart\n        } else if (part=='#value') {\n            return curr\n        } else if (part=='#root') {\n            curr = root\n        } else {\n            part = decodeURIComponent(part)\n            curr = curr[part];\n            prevPart = part\n        }\n    }\n    return curr\n}\n\n/**\n * Default transformer for data binding\n * Will be used unless overriden in the SimplyBind options parameter\n */\nexport function defaultTransformer(context) {\n    const el = context.element\n    const templates = context.templates\n    const templatesCount = templates.length \n    const path = context.path\n    const value = context.value\n    const attribute = this.options.attribute\n    if (Array.isArray(value) && templates?.length) {\n        transformArrayByTemplates.call(this, context)\n    } else if (value && typeof value == 'object' && templates?.length) {\n        transformObjectByTemplates.call(this, context)\n    } else if (el.tagName=='INPUT') {\n        transformInput.call(this, context)\n    } else if (el.tagName=='BUTTON') {\n        transformButton.call(this, context)\n    } else if (el.tagName=='SELECT') {\n        transformSelect.call(this, context)\n    } else if (el.tagName=='A') {\n        transformAnchor.call(this, context)\n    } else {\n        transformElement.call(this, context)\n    }\n    return context\n}\n\n/**\n * Renders an array value by applying templates for each entry\n * Replaces or removes existing DOM children if needed\n * Reuses (doesn't touch) DOM children if template doesn't change\n */\nexport function transformArrayByTemplates(context) {\n    const el             = context.element\n    const templates      = context.templates\n    const templatesCount = templates.length \n    const path           = context.path\n    const value          = context.value\n    const attribute      = this.options.attribute\n\n    let items = el.querySelectorAll(':scope > ['+attribute+'-key]')\n    // do single merge strategy for now, in future calculate optimal merge strategy from a number\n    // now just do a delete if a key <= last key, insert if a key >= last key\n    let lastKey = 0\n    let skipped = 0\n    for (let item of items) {\n        let currentKey = parseInt(item.getAttribute(attribute+'-key'))\n        if (currentKey>lastKey) {\n            // insert before\n            el.insertBefore(this.applyTemplate(path, templates, value, lastKey), item)\n        } else if (currentKey<lastKey) {\n            // remove this\n            item.remove()\n        } else {\n            // check that all data-bind params start with current json path or a '#', otherwise replaceChild\n            let bindings = Array.from(item.querySelectorAll(`[${attribute}]`))\n            if (item.matches(`[${attribute}]`)) {\n                bindings.unshift(item)\n            }\n            let needsReplacement = bindings.find(b => {\n                let databind = b.getAttribute(attribute)\n                return (databind.substr(0,5)!=='#root' \n                    && databind.substr(0, path.length)!==path)\n            })\n            if (!needsReplacement) {\n                if (item.$bindTemplate) {\n                    let newTemplate = this.findTemplate(templates, value[lastKey])\n                    if (newTemplate != item.$bindTemplate){\n                        needsReplacement = true\n                        if (!newTemplate) {\n                            skipped++\n                        }\n                    }\n                }\n            }\n            if (needsReplacement) {\n                el.replaceChild(this.applyTemplate(path, templates, value, lastKey), item)\n            }\n        }\n        lastKey++\n        if (lastKey>=value.length) {\n            break\n        }\n    }\n    items = el.querySelectorAll(':scope > ['+attribute+'-key]')\n    let length = items.length + skipped\n    if (length > value.length) {\n        while (length > value.length) {\n            let child = el.querySelectorAll(':scope > :not(template)')?.[length-1]\n            child?.remove()\n            length--\n        }\n    } else if (length < value.length ) {\n        while (length < value.length) {\n            el.appendChild(this.applyTemplate(path, templates, value, length))\n            length++\n        }\n    }\n}\n\n/**\n * Renders an object value by applying templates for each entry (Object.entries)\n * Replaces or removes existing DOM children if needed\n * Reuses (doesn't touch) DOM children if template doesn't change\n */\nexport function transformObjectByTemplates(context) {\n    const el             = context.element\n    const templates      = context.templates\n    const templatesCount = templates.length \n    const path           = context.path\n    const value          = context.value\n    const attribute      = this.options.attribute\n    \n    let list    = Object.entries(value)\n    let items   = el.querySelectorAll(':scope > ['+attribute+'-key]')\n    let current = 0\n    let skipped = 0\n    for (let item of items) {\n        if (current>=list.length) {\n            break\n        }\n        let key = list[current][0]\n        current++\n        let keypath = path+'.'+key\n        // check that all data-bind params start with current json path or a '#', otherwise replaceChild\n        let needsReplacement\n        const databind = item.getAttribute(attribute)\n        if (databind && databind.substr(0, keypath.length)!=keypath) {\n            needsReplacement=true\n        } else {\n            let bindings = Array.from(item.querySelectorAll(`[${attribute}]`))\n            needsReplacement = bindings.find(b => {\n                const db = b.getAttribute(attribute)\n                return (db.substr(0,5)!=='#root' && db.substr(0, keypath.length)!==keypath)\n            })\n            if (!needsReplacement) {\n                if (item.$bindTemplate) {\n                    let newTemplate = this.findTemplate(templates, value[key])\n                    if (newTemplate != item.$bindTemplate){\n                        needsReplacement = true\n                        if (!newTemplate) {\n                            skipped++\n                        }\n                    }\n                }\n            }\n        }\n        if (needsReplacement) {\n            let clone = this.applyTemplate(path, templates, value, key)\n            el.replaceChild(clone, item)\n        }\n    }\n    items  = el.querySelectorAll(':scope > ['+attribute+'-key]')\n    let length = items.length + skipped\n    if (length>list.length) {\n        while (length>list.length) {\n            let child = el.querySelectorAll(':scope > :not(template)')?.[length-1]\n            child?.remove()\n            length--\n        }\n    } else if (length < list.length) {\n        while (length < list.length) {\n            let key = list[length][0]\n            el.appendChild(this.applyTemplate(path, templates, value, key))\n            length++\n        }\n    } \n}\n\n/**\n * transforms a single input type\n * for radio/checkbox inputs it only sets the checked attribute to true/false\n * if the value attribute matches the current value\n * for other inputs the value attribute is updated\n * FIXME: handle radio/checkboxes in separate transformer\n */\nexport function transformInput(context) {\n    const el    = context.element\n    const value = context.value\n\n    if (el.type=='checkbox' || el.type=='radio') {\n        if (matchValue(el.value, value)) {\n            el.checked = true\n        } else {\n            el.checked = false\n        }\n    } else if (!matchValue(el.value, value)) {\n        el.value = ''+value\n    }\n}\n\n/**\n * Sets the value of the button, doesn't touch the innerHTML\n */\nexport function transformButton(context) {\n    const el    = context.element\n    const value = context.value\n\n    if (!matchValue(el.value,value)) {\n        el.value = ''+value\n    }\n}\n\n/**\n * Sets the selected attribute of select options\n */\nexport function transformSelect(context) {\n    const el    = context.element\n    const value = context.value\n\n    if (el.multiple) {\n        if (Array.isArray(value)) {\n            for (let option of el.options) {\n                if (value.indexOf(option.value)===false) {\n                    option.selected = false\n                } else {\n                    option.selected = true\n                }\n            }\n        }\n    } else {\n        let option = el.options.find(o => matchValue(o.value,value))\n        if (option) {\n            option.selected = true\n        }\n    }\n}\n\n/**\n * Sets the innerHTML and href attribute of an anchor\n * TODO: support target, title, etc. attributes\n */\nexport function transformAnchor(context) {\n    const el    = context.element\n    const value = context.value\n\n    if (value?.innerHTML && !matchValue(el.innerHTML, value.innerHTML)) {\n        el.innerHTML = ''+value.innerHTML\n    }\n    if (value?.href && !matchValue(el.href,value.href)) {\n        el.href = ''+value.href\n    }    \n}\n\n/**\n * sets the innerHTML of any HTML element\n */\nexport function transformElement(context) {\n    const el    = context.element\n    const value = context.value\n\n    if (!matchValue(el.innerHTML, value)) {\n        el.innerHTML = ''+value\n    }\n}", "import { routes } from './route.mjs'\nimport { commands } from './command.mjs'\nimport { actions } from './action.mjs'\nimport { keys } from './key.mjs'\nimport { signal } from './state.mjs'\nimport { bind } from './bind.mjs'\n\nclass SimplyApp {\n\tconstructor(options={}) {\n\t\tthis.container = options.container || document.body\n\t\tif (options.state) {\n\t\t\tthis.state = signal(options.state)\n\t\t}\n\t\tif (options.commands) {\n\t\t\tthis.commands = commands({ app: this, container: this.container, commands: options.commands})\n\t\t}\n\t\tif (options.keys) {\n\t\t\tthis.keys = keys({ app: this, keys: options.keys })\n\t\t}\n\t\tif (options.routes) {\n\t\t\tthis.routes = routes({ app: this, routes: options.routes})\n\t\t}\n\t\tif (options.actions) {\n\t\t\tthis.actions = actions({app: this, actions: options.actions})\n\t\t}\n\t\tbind({ container: this.container, state: this.state })\n\t}\n}\n\nexport function app(options={}) {\n\treturn new SimplyApp(options)\n}"],
  "mappings": "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",
  "names": []
}
