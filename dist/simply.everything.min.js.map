{
  "version": 3,
  "sources": ["../src/activate.mjs", "../src/action.mjs", "../src/route.mjs", "../src/command.mjs", "../src/key.mjs", "../src/state.mjs", "../src/bind.mjs", "../src/app.mjs", "../src/include.mjs", "../src/model.mjs", "../src/everything.mjs"],
  "sourcesContent": ["const listeners = new Map()\n\nexport const activate = {\n    addListener: (name, callback) => {\n        if (!listeners.has(name)) {\n            listeners.set(name, [])\n        }\n        listeners.get(name).push(callback)\n        initialCall(name)\n    },\n    removeListener: (name, callback) => {\n        if (!listeners.has(name)) {\n            return false\n        }\n        listeners.set(name, listeners.get(name).filter((listener) => {\n            return listener!=callback\n        }))\n    }\n}\n\nfunction initialCall(name) {\n    const nodes = document.querySelectorAll('[data-simply-activate=\"'+name+'\"]')\n    if (nodes) {\n        for( let node of nodes) {\n            callListeners(node)\n        }\n    }\n}\n\nfunction callListeners(node) {\n    const activate = node?.dataset?.simplyActivate\n    if (activate && listeners.has(activate)) {\n        for (let callback of listeners.get(activate)) {\n            callback.call(node)\n        }\n    }\n}\n\nfunction handleChanges(changes) {\n    let activateNodes = []\n    for (let change of changes) {\n        if (change.type == 'childList') {\n            for (let node of change.addedNodes) {\n                if (node.querySelectorAll) {\n                    var toActivate = Array.from(node.querySelectorAll('[data-simply-activate]'))\n                    if (node.matches('[data-simply-activate]')) {\n                        toActivate.push(node)\n                    }\n                    activateNodes = activateNodes.concat(toActivate)\n                }\n            }\n        }\n    }\n    for (let node of activateNodes) {\n        callListeners(node)\n    }\n}\n\nconst observer = new MutationObserver(handleChanges)\nobserver.observe(document, {\n    subtree: true,\n    childList: true\n})", "class SimplyActions {\n\tconstructor(options) {\n        this.app = options.app\n        \n\t\tconst actionHandler = {\n\t\t\tget: (target, property) => {\n\t\t\t\treturn target[property].bind(this.app)\n\t\t\t}\n\t\t}\n\n\t\tthis.actions = new Proxy({}, actionHandler)\n\t\tObject.assign(this.actions, options.actions)\n\t}\n}\n\nexport function actions(options) {\n\treturn new SimplyActions(options)\n}", "export function routes(options) {\n\treturn new SimplyRoute(options)\n}\n\nclass SimplyRoute {\n\tconstructor(options={}) {\n\t\tthis.root = options.root || '/'\n        this.app = options.app\n\t\tthis.clear()\n\t\tif (options.routes) {\n\t\t\tthis.load(options.routes)\n\t\t}\n\t}\n\n\tload(routes) {\n\t\tparseRoutes(routes, this.routeInfo)\n\t}\n\n\tclear() {\n\t\tthis.routeInfo = []\n\t\tthis.listeners = {\n\t\t\tmatch: {},\n\t\t\tcall: {},\n\t\t\tfinish: {}\n\t\t}\n\t}\n\n\tmatch(path, options) {\n\t\tlet args = {\n            path,\n            options\n        }\n        args = this.runListeners('match',args)\n        path = args.path ? args.path : path;\n\n        let matches;\n        if (!path) {\n            if (this.match(document.location.pathname+document.location.hash)) {\n                return true;\n            } else {\n                return this.match(document.location.pathname);\n            }\n        }\n        path = getPath(path);\n        for ( let route of this.routeInfo) {\n            matches = route.match.exec(path)\n            if (matches && matches.length) {\n                var params = {};\n                route.params.forEach((key, i) => {\n                    if (key=='*') {\n                        key = 'remainder'\n                    }\n                    params[key] = matches[i+1]\n                })\n                Object.assign(params, options)\n                args.route = route\n                args.params = params\n                args = this.runListeners('call', args)\n                params = args.params ? args.params : params\n                args.result = route.action.call(route, params)\n                this.runListeners('finish', args)\n                return args.result\n            }\n        }\n        if (path && path[path.length-1]!='/') {\n        \treturn this.match(path+'/', options)\n        }\n        return false\n\t}\n\n\trunListeners(action, params) {\n        if (!Object.keys(this.listeners[action])) {\n            return\n        }\n        Object.keys(this.listeners[action]).forEach((route) => {\n            var routeRe = getRegexpFromRoute(route);\n            if (routeRe.exec(params.path)) {\n                var result;\n                for (let callback of this.listeners[action][route]) {\n                    result = callback.call(this.app, params)\n                    if (result) {\n                        params = result\n                    }\n                }\n            }\n        })\n        return params\n    }\n\n    handleEvents() {\n        globalThis.addEventListener('popstate', () => {\n            if (this.match(getPath(document.location.pathname + document.location.hash, this.root)) === false) {\n                this.match(getPath(document.location.pathname, this.root))\n            }\n        })\n        globalThis.document.addEventListener('click', (evt) => {\n\t        if (evt.ctrlKey) {\n\t            return;\n\t        }\n\t        if (evt.which != 1) {\n\t            return; // not a 'left' mouse click\n\t        }\n\t        var link = evt.target;\n\t        while (link && link.tagName!='A') {\n\t            link = link.parentElement;\n\t        }\n\t        if (link \n\t            && link.pathname \n\t            && link.hostname==globalThis.location.hostname \n\t            && !link.link\n\t            && !link.dataset.simplyCommand\n\t        ) {\n\t            let path = getPath(link.pathname+link.hash, this.root);\n\t            if ( !this.has(path) ) {\n\t                path = getPath(link.pathname, this.root);\n\t            }\n\t            if ( this.has(path) ) {\n\t                let params = this.runListeners('goto', { path: path});\n\t                if (params.path) {\n\t                    this.goto(params.path);\n\t                }\n\t                evt.preventDefault();\n\t                return false;\n\t            }\n\t        }\n\t    })\n    }\n\n    goto(path) {\n        history.pushState({},'',getURL(path))\n        return this.match(path)\n    }\n\n    has(path) {\n    \tpath = getPath(path, this.root)\n    \tfor (let route of this.routeInfo) {\n            var matches = route.match.exec(path)\n            if (matches && matches.length) {\n                return true\n            }\n        }\n        return false\n    }\n\n    addListener(action, route, callback) {\n        if (['goto','match','call','finish'].indexOf(action)==-1) {\n            throw new Error('Unknown action '+action)\n        }\n        if (!this.listeners[action][route]) {\n            this.listeners[action][route] = []\n        }\n        this.listeners[action][route].push(callback)\n    }\n\n    removeListener(action, route, callback) {\n        if (['match','call','finish'].indexOf(action)==-1) {\n            throw new Error('Unknown action '+action)\n        }\n        if (!this.listeners[action][route]) {\n            return\n        }\n        this.listeners[action][route] = this.listeners[action][route].filter((listener) => {\n            return listener != callback\n        })\n    }\n\n    init(options) {\n    \tif (options.root) {\n    \t\tthis.root = options.root\n    \t}\n    }\n}\n\nfunction getPath(path, root='/') {\n    if (path.substring(0,root.length)==root\n        ||\n        ( root[root.length-1]=='/' \n            && path.length==(root.length-1)\n            && path == root.substring(0,path.length)\n        )\n    ) {\n        path = path.substring(root.length)\n    }\n    if (path[0]!='/' && path[0]!='#') {\n        path = '/'+path\n    }\n    return path\n}\n\nfunction getURL(path, root) {\n    path = getPath(path, root)\n    if (root[root.length-1]==='/' && path[0]==='/') {\n        path = path.substring(1)\n    }\n    return root + path;\n}\n\nfunction getRegexpFromRoute(route) {\n    return new RegExp('^'+route.replace(/:\\w+/g, '([^/]+)').replace(/:\\*/, '(.*)'));\n}\n\nfunction parseRoutes(routes) {\n    let routeInfo = []\n    const paths = Object.keys(routes)\n    const matchParams = /:(\\w+|\\*)/g\n    for (let path of paths) {\n        let matches = []\n        let params  = []\n        do {\n            matches = matchParams.exec(path)\n            if (matches) {\n                params.push(matches[1])\n            }\n        } while(matches)\n        routeInfo.push({\n            match:  getRegexpFromRoute(path),\n            params: params,\n            action: routes[path]\n        })\n    }\n    return routeInfo\n}\n", "class SimplyCommands {\n\tconstructor(options={}) {\n\t\tif (!options.app) {\n\t\t\toptions.app = {}\n\t\t}\n\t\tif (!options.app.container) {\n\t\t\toptions.app.container = document.body\n\t\t}\n\t\tthis.app = options.app\n\t\tthis.handlers = options.handlers || defaultHandlers\n\t\tthis.commands = options.commands || {}\n\n\t\tconst commandHandler = (evt) => {\n\t\t\tconst command = getCommand(evt, this.handlers)\n\t\t\tif (!command) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (!this.commands[command.name]) {\n                console.error('simply.command: undefined command '+command.name, command.source);\n                return\n\t\t\t}\n\t\t\tthis.commands[command.name].call(this.app, command.source, command.value)\n\t\t}\n\n        function stop(fn) {\n            return (evt) => {\n                fn(evt)\n                evt.preventDefault()\n                evt.stopPropagation()\n                return false                \n            }\n        }\n\n        this.app.container.addEventListener('click', stop(commandHandler))\n        this.app.container.addEventListener('submit', stop(commandHandler))\n        this.app.container.addEventListener('change', commandHandler)\n        this.app.container.addEventListener('input', commandHandler)\n\t}\n}\n\nexport function commands(options={}) {\n\treturn new SimplyCommands(options)\n}\n\nfunction getCommand(evt, handlers) {\n    var el = evt.target.closest('[data-simply-command]')\n    if (el) {\n        for (let handler of handlers) {\n            if (el.matches(handler.match)) {\n                if (handler.check(el, evt)) {\n                    return {\n                        name:   el.dataset.simplyCommand,\n                        source: el,\n                        value:  handler.get(el)\n                    }\n                }\n                return null\n            }\n        }\n    }\n    return null\n}\n\nconst defaultHandlers = [\n    {\n        match: 'input,select,textarea',\n        get: function(el) {\n            if (el.tagName==='SELECT' && el.multiple) {\n                let values = []\n                for (let option of el.options) {\n                    if (option.selected) {\n                        values.push(option.value)\n                    }\n                }\n                return values\n            }\n            return el.dataset.simplyValue || el.value\n        },\n        check: function(el, evt) {\n            return evt.type=='change' || (el.dataset.simplyImmediate && evt.type=='input')\n        }\n    },\n    {\n        match: 'a,button',\n        get: function(el) {\n            return el.dataset.simplyValue || el.href || el.value\n        },\n        check: function(el,evt) {\n            return evt.type=='click' && evt.ctrlKey==false && evt.button==0\n        }\n    },\n    {\n        match: 'form',\n        get: function(el) {\n            let data = {}\n            for (let input of Array.from(el.elements)) {\n                if (input.tagName=='INPUT' \n                    && (input.type=='checkbox' || input.type=='radio')\n                ) {\n                    if (!input.checked) {\n                        return;\n                    }\n                }\n                if (data[input.name] && !Array.isArray(data[input.name])) {\n                    data[input.name] = [data[input.name]]\n                }\n                if (Array.isArray(data[input.name])) {\n                    data[input.name].push(input.value)\n                } else {\n                    data[input.name] = input.value\n                }\n            }\n            return data\n        },\n        check: function(el,evt) {\n            return evt.type=='submit'\n        }\n    },\n    {\n    \tmatch: '*',\n        get: function(el) {\n            return el.dataset.simplyValue\n        },\n        check: function(el, evt) {\n            return evt.type=='click' && evt.ctrlKey==false && evt.button==0\n        }\n    }\n]", "class SimplyKeys {\n\tconstructor(options = {}) {\n\t\tif (!options.app) {\n\t\t\toptions.app = {}\n\t\t}\n\t\tif (!options.app.container) {\n\t\t\toptions.app.container = document.body\n\t\t}\n\t\tthis.keys = options.keys || {}\n\t\tthis.app = options.app\n\t\tthis.app.container.addEventListener('keydown', this.keyHandler())\n\t}\n\n\tkeyHandler() {\n\t\treturn (e) => {\n\t\t\tif (e.isComposing || e.keyCode === 229) {\n\t\t\t    return;\n\t\t\t}\n\t\t\tif (e.defaultPrevented) {\n\t\t\t    return;\n\t\t\t}\n\t\t\tif (!e.target) {\n\t\t\t    return;\n\t\t\t}\n\n\t\t\tlet selectedKeyboard = 'default';\n\t\t\tif (e.target.closest('[data-simply-keyboard]')) {\n\t\t\t    selectedKeyboard = e.target.closest('[data-simply-keyboard]').dataset.simplyKeyboard;\n\t\t\t}\n\t\t\tlet key = '';\n\t\t\tif (e.ctrlKey && e.keyCode!=17) {\n\t\t\t    key+='Control+';\n\t\t\t}\n\t\t\tif (e.metaKey && e.keyCode!=224) {\n\t\t\t    key+='Meta+';\n\t\t\t}\n\t\t\tif (e.altKey && e.keyCode!=18) {\n\t\t\t    key+='Alt+';\n\t\t\t}\n\t\t\tif (e.shiftKey && e.keyCode!=16) {\n\t\t\t    key+='Shift+';\n\t\t\t}\n\t\t\tkey+=e.key;\n\n\t\t\tif (this.keys[selectedKeyboard] && this.keys[selectedKeyboard][key]) {\n\t\t\t    let keyboard = this.keys[selectedKeyboard]\n\t\t\t    keyboard[key].call(this.app,e);\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport function keys(options={}) {\n\treturn new SimplyKeys(options)\n}\n\n", "const source = Symbol('source')\nconst iterate = Symbol('iterate')\n\nconst signalHandler = {\n    get: (target, property, receiver) => {\n        if (property===source) {\n            return target // don't notifyGet here, this is only called by set\n        }\n        const value = target?.[property] // Reflect.get fails on a Set.\n        notifyGet(receiver, property)\n        if (typeof value === 'function') {\n            if (Array.isArray(target)) {\n                return (...args) => {\n                    let l = target.length\n                    // by binding the function to the receiver\n                    // all accesses in the function will be trapped\n                    // by the Proxy, so get/set/delete is all handled\n                    let result = value.apply(receiver, args)\n                    if (l != target.length) {\n                        notifySet(receiver,  makeContext('length', { was: l, now: target.length }) )\n                    }\n                    return result\n                }\n            } else if (target instanceof Set || target instanceof Map) {\n                return (...args) => {\n                    // node doesn't allow you to call set/map functions\n                    // bound to the receiver.. so using target instead\n                    // there are no properties to update anyway, except for size\n                    let s = target.size\n                    let result = value.apply(target, args)\n                    if (s != target.size) {\n                        notifySet(receiver, makeContext( 'size', { was: s, now: target.size }) )\n                    }\n                    // there is no efficient way to see if the function called\n                    // has actually changed the Set/Map, but by assuming the\n                    // 'setter' functions will change the results of the\n                    // 'getter' functions, effects should update correctly\n                    if (['set','add','clear','delete'].includes(property)) {\n                        notifySet(receiver, makeContext( { entries: {}, forEach: {}, has: {}, keys: {}, values: {}, [Symbol.iterator]: {} } ) )\n                    }\n                    return result\n                }\n            } else {\n                // support custom classes, hopefully\n                return value.bind(receiver)\n            }\n        }\n        if (value && typeof value == 'object') {\n            //NOTE: get now returns a signal, set doesn't 'unsignal' the value set\n            return signal(value)\n        }\n        return value\n    },\n    set: (target, property, value, receiver) => {\n        value = value?.[source] || value // unwraps signal\n        let current = target[property]\n        if (current!==value) {\n            target[property] = value\n            notifySet(receiver, makeContext(property, { was: current, now: value } ) )\n        }\n        if (typeof current === 'undefined') {\n            notifySet(receiver, makeContext(iterate, {}))\n        }\n        return true\n    },\n    has: (target, property) => { // receiver is not part of the has() call\n        let receiver = signals.get(target) // so retrieve it here\n        if (receiver) {\n            notifyGet(receiver, property)\n        }\n        return Object.hasOwn(target, property)\n    },\n    deleteProperty: (target, property) => {\n        if (typeof target[property] !== 'undefined') {\n            let current = target[property]\n            delete target[property]\n            let receiver = signals.get(target) // receiver is not part of the trap arguments, so retrieve it here\n            notifySet(receiver, makeContext(property,{ delete: true, was: current }))\n        }\n        return true\n    },\n    defineProperty: (target, property, descriptor) => {\n        if (typeof target[property] === 'undefined') {\n            let receiver = signals.get(target) // receiver is not part of the trap arguments, so retrieve it here\n            notifySet(receiver, makeContext(iterate, {}))\n        }\n        return Object.defineProperty(target, property, descriptor)\n    },\n    ownKeys: (target) => {\n        let receiver = signals.get(target) // receiver is not part of the trap arguments, so retrieve it here\n        notifyGet(receiver, iterate)\n        return Reflect.ownKeys(target)\n    }\n\n}\n\n/**\n * Keeps track of the return signal for an update function, as well\n * as signals connected to other objects. \n * Makes sure that a given object or function always uses the same\n * signal\n */\nconst signals = new WeakMap()\n\n/**\n * Creates a new signal proxy of the given object, that intercepts get/has and set/delete\n * to allow reactive functions to be triggered when signal values change.\n */\nexport function signal(v) {\n    if (!signals.has(v)) {\n        signals.set(v, new Proxy(v, signalHandler))\n    }\n    return signals.get(v)\n}\n\nlet batchedListeners = new Set()\nlet batchMode = 0\n/**\n * Called when a signal changes a property (set/delete)\n * Triggers any reactor function that depends on this signal\n * to re-compute its values\n */\nfunction notifySet(self, context={}) {\n    let listeners = []\n    context.forEach((change, property) => {\n        let propListeners = getListeners(self, property)\n        if (propListeners?.length) {\n            for (let listener of propListeners) {\n                addContext(listener, makeContext(property,change))\n            }\n            listeners = listeners.concat(propListeners)\n        }\n    })\n    listeners = new Set(listeners.filter(Boolean))\n    if (listeners) {\n        if (batchMode) {\n            batchedListeners = batchedListeners.union(listeners)\n        } else {\n            const currentEffect = computeStack[computeStack.length-1]\n            for (let listener of Array.from(listeners)) {\n                if (listener!=currentEffect && listener?.needsUpdate) {\n                    listener()\n                }\n                clearContext(listener)\n            }\n        }\n    }\n}\n\nfunction makeContext(property, change) {\n    let context = new Map()\n    if (typeof property === 'object') {\n        for (let prop in property) {\n            context.set(prop, property[prop])\n        }\n    } else {\n        context.set(property, change)\n    }\n    return context\n}\n\nfunction addContext(listener, context) {\n    if (!listener.context) {\n        listener.context = context\n    } else {\n        context.forEach((change,property)=> {\n            listener.context.set(property, change) // TODO: merge change if needed\n        })\n    }\n    listener.needsUpdate = true\n}\n\nfunction clearContext(listener) {\n    delete listener.context\n    delete listener.needsUpdate\n}\n\n/**\n * Called when a signal property is accessed. If this happens\n * inside a reactor function--computeStack is not empty--\n * then it adds the current reactor (top of this stack) to its\n * listeners. These are later called if this property changes\n */\nfunction notifyGet(self, property) {\n    let currentCompute = computeStack[computeStack.length-1]\n    if (currentCompute) {\n        // get was part of a react() function, so add it\n        setListeners(self, property, currentCompute)\n    }\n}\n\n/**\n * Keeps track of which update() functions are dependent on which\n * signal objects and which properties. Maps signals to update fns\n */\nconst listenersMap = new WeakMap()\n\n/**\n * Keeps track of which signals and properties are linked to which\n * update functions. Maps update functions and properties to signals\n */\nconst computeMap = new WeakMap()\n\n/**\n * Returns the update functions for a given signal and property\n */\nfunction getListeners(self, property) {\n    let listeners = listenersMap.get(self)\n    return listeners ? Array.from(listeners.get(property) || []) : []\n}\n\n/**\n * Adds an update function (compute) to the list of listeners on\n * the given signal (self) and property\n */\nfunction setListeners(self, property, compute) {\n    if (!listenersMap.has(self)) {\n        listenersMap.set(self, new Map())\n    }\n    let listeners = listenersMap.get(self)\n    if (!listeners.has(property)) {\n        listeners.set(property, new Set())\n    }\n    listeners.get(property).add(compute)\n\n    if (!computeMap.has(compute)) {\n        computeMap.set(compute, new Map())\n    }\n    let connectedSignals = computeMap.get(compute)\n    if (!connectedSignals.has(property)) {\n        connectedSignals.set(property, new Set)\n    }\n    connectedSignals.get(property).add(self)\n}\n\n/**\n * Removes alle listeners that trigger the given reactor function (compute)\n * This happens when a reactor is called, so that it can set new listeners\n * based on the current call (code path)\n */\nfunction clearListeners(compute) {\n    let connectedSignals = computeMap.get(compute)\n    if (connectedSignals) {\n        connectedSignals.forEach(property => {\n            property.forEach(s => {\n                let listeners = listenersMap.get(s)\n                if (listeners.has(property)) {\n                    listeners.get(property).delete(compute)\n                }\n            })\n        })\n    }\n}\n\n/**\n * The top most entry is the currently running update function, used\n * to automatically record signals used in an update function.\n */\nlet computeStack = []\n\n/**\n * Used for cycle detection: effectStack contains all running effect\n * functions. If the same function appears twice in this stack, there\n * is a recursive update call, which would cause an infinite loop.\n */\nconst effectStack = []\n\nconst effectMap = new WeakMap()\n/**\n * Used for cycle detection: signalStack contains all used signals. \n * If the same signal appears more than once, there is a cyclical \n * dependency between signals, which would cause an infinite loop.\n */\nconst signalStack = []\n\n/**\n * Runs the given function at once, and then whenever a signal changes that\n * is used by the given function (or at least signals used in the previous run).\n */\nexport function effect(fn) {\n    if (effectStack.findIndex(f => fn==f)!==-1) {\n        throw new Error('Recursive update() call', {cause:fn})\n    }\n    effectStack.push(fn)\n\n    let connectedSignal = signals.get(fn)\n    if (!connectedSignal) {\n        connectedSignal = signal({\n            current: null\n        })\n        signals.set(fn, connectedSignal)\n    }\n\n    // this is the function that is called automatically\n    // whenever a signal dependency changes\n    const computeEffect = function computeEffect() {\n        if (signalStack.findIndex(s => s==connectedSignal)!==-1) {\n            throw new Error('Cyclical dependency in update() call', { cause: fn})\n        }\n        // remove all dependencies (signals) from previous runs \n        clearListeners(computeEffect)\n        // record new dependencies on this run\n        computeStack.push(computeEffect)\n        // prevent recursion\n        signalStack.push(connectedSignal)\n        // call the actual update function\n        let result\n        try {\n            result = fn(computeEffect, computeStack, signalStack)\n        } finally {\n            // stop recording dependencies\n            computeStack.pop()\n            // stop the recursion prevention\n            signalStack.pop()\n            if (result instanceof Promise) {\n                result.then((result) => {\n                    connectedSignal.current = result\n                })\n            } else {\n                connectedSignal.current = result\n            }\n        }\n    }\n    computeEffect.fn = fn\n    effectMap.set(connectedSignal, computeEffect)\n\n    // run the computEffect immediately upon creation\n    computeEffect()\n    return connectedSignal\n}\n\n\nexport function destroy(connectedSignal) {\n    // find the computeEffect associated with this signal\n    const computeEffect = effectMap.get(connectedSignal)?.deref()\n    if (!computeEffect) {\n        return\n    }\n\n    // remove all listeners for this effect\n    clearListeners(computeEffect)\n\n    // remove all references to connectedSignal\n    let fn = computeEffect.fn\n    signals.remove(fn)\n\n    effectMap.delete(connectedSignal)\n\n    // if no other references to connectedSignal exist, it will be garbage collected\n}\n\n/**\n * Inside a batch() call, any changes to signals do not trigger effects\n * immediately. Instead, immediately after finishing the batch() call,\n * these effects will be called. Effects that are triggered by multiple\n * signals are called only once.\n * @param Function fn batch() calls this function immediately\n * @result mixed the result of the fn() function call\n */\nexport function batch(fn) {\n    batchMode++\n    let result\n    try {\n        result = fn()\n    } finally {\n        if (result instanceof Promise) {\n            result.then(() => {\n                batchMode--\n                if (!batchMode) {\n                    runBatchedListeners()\n                }\n            })\n        } else {\n            batchMode--\n            if (!batchMode) {\n                runBatchedListeners()\n            }\n        }\n    }\n    return result\n}\n\nfunction runBatchedListeners() {\n    let copyBatchedListeners = Array.from(batchedListeners)\n    batchedListeners = new Set()\n    const currentEffect = computeStack[computeStack.length-1]\n    for (let listener of copyBatchedListeners) {\n        if (listener!=currentEffect && listener?.needsUpdate) {\n            listener()\n        }\n        clearContext(listener)\n    }\n}\n\n/**\n * A throttledEffect is run immediately once. And then only once\n * per throttleTime (in ms).\n * @param Function fn the effect function to run whenever a signal changes\n * @param int throttleTime in ms\n * @returns signal with the result of the effect function fn\n */\nexport function throttledEffect(fn, throttleTime) {\n    if (effectStack.findIndex(f => fn==f)!==-1) {\n        throw new Error('Recursive update() call', {cause:fn})\n    }\n    effectStack.push(fn)\n\n    let connectedSignal = signals.get(fn)\n    if (!connectedSignal) {\n        connectedSignal = signal({\n            current: null\n        })\n        signals.set(fn, connectedSignal)\n    }\n\n    let throttled = false\n    let hasChange = true\n    // this is the function that is called automatically\n    // whenever a signal dependency changes\n    const computeEffect = function computeEffect() {\n        if (signalStack.findIndex(s => s==connectedSignal)!==-1) {\n            throw new Error('Cyclical dependency in update() call', { cause: fn})\n        }\n        if (throttled && throttled>Date.now()) {\n            hasChange = true\n            return\n        }\n        // remove all dependencies (signals) from previous runs \n        clearListeners(computeEffect)\n        // record new dependencies on this run\n        computeStack.push(computeEffect)\n        // prevent recursion\n        signalStack.push(connectedSignal)\n        // call the actual update function\n        let result\n        try {\n            result = fn(computeEffect, computeStack, signalStack)\n        } finally {\n            hasChange = false\n            // stop recording dependencies\n            computeStack.pop()\n            // stop the recursion prevention\n            signalStack.pop()\n            if (result instanceof Promise) {\n                result.then((result) => {\n                    connectedSignal.current = result\n                })\n            } else {\n                connectedSignal.current = result\n            }\n        }\n        throttled = Date.now()+throttleTime\n        globalThis.setTimeout(() => {\n            if (hasChange) {\n                computeEffect()\n            }\n        }, throttleTime)\n    }\n    // run the computEffect immediately upon creation\n    computeEffect()\n    return connectedSignal\n}\n\n// refactor: Class clock() with an effect() method\n// keep track of effects per clock, and add clock property to the effect function\n// on notifySet add clock.effects to clock.needsUpdate list\n// on clock.tick() (or clock.time++) run only the clock.needsUpdate effects \n// (first create a copy and reset clock.needsUpdate, then run effects)\nexport function clockEffect(fn, clock) {\n    let connectedSignal = signals.get(fn)\n    if (!connectedSignal) {\n        connectedSignal = signal({\n            current: null\n        })\n        signals.set(fn, connectedSignal)\n    }\n\n    let lastTick = -1 // clock.time should start at 0 or larger\n    let hasChanged = true // make sure the first run goes through\n    // this is the function that is called automatically\n    // whenever a signal dependency changes\n    const computeEffect = function computeEffect() {\n        if (lastTick < clock.time) {\n            if (hasChanged) {\n                // remove all dependencies (signals) from previous runs \n                clearListeners(computeEffect)\n                // record new dependencies on this run\n                computeStack.push(computeEffect)\n                // make sure the clock.time signal is a dependency\n                lastTick = clock.time\n                // call the actual update function\n                let result \n                try {\n                    result = fn(computeEffect, computeStack)\n                } finally {\n                    // stop recording dependencies\n                    computeStack.pop()\n                    if (result instanceof Promise) {\n                        result.then((result) => {\n                            connectedSignal.current = result\n                        })\n                    } else {\n                        connectedSignal.current = result\n                    }\n                    hasChanged = false\n                }\n            } else {\n                lastTick = clock.time\n            }\n        } else {\n            hasChanged = true\n        }\n    }\n    // run the computEffect immediately upon creation\n    computeEffect()\n    return connectedSignal\n}\n\nexport function untracked(fn) {\n    const remember = computeStack.slice()\n    computeStack = []\n    try {\n        return fn()\n    } finally {\n        computeStack = remember\n    }\n}", "import { throttledEffect } from './state.mjs'\n\nclass SimplyBind {\n    constructor(options) {\n        const defaultOptions = {\n            container: document.body,\n            attribute: 'data-bind',\n            transformers: [],\n            defaultTransformers: [defaultTransformer]\n        }\n        if (!options?.root) {\n            throw new Error('bind needs at least options.root set')\n        }\n        this.options = Object.assign({}, defaultOptions, options)\n\n        const attribute = this.options.attribute\n\n        // sets up the effect that updates the element if its\n        // data binding value changes\n        const render = (el) => {\n            throttledEffect(() => {\n                const context = {\n                    templates: el.querySelectorAll(':scope > template'),\n                    path: this.getBindingPath(el)\n                }\n                context.value = getValueByPath(this.options.root, context.path)\n                context.element = el\n                runTransformers(context)\n            }, 100)\n        }\n\n        // finds and runs applicable transformers\n        // creates a stack of transformers, calls the topmost\n        // each transformer can opt to call the next or not\n        // transformers should return the context object (possibly altered)\n        const runTransformers = (context) => {\n            let transformers = this.options.defaultTransformers || []\n            if (context.element.dataset.transform) {\n                context.element.dataset.transform.split(' ').filter(Boolean).forEach(t => {\n                    if (this.options.transformers[t]) {\n                        transformers.push(this.options.transformers[t])\n                    } else {\n                        console.warn('No transformer with name '+t+' configured', {cause:context.element})\n                    }\n                })\n            }\n            let next\n            for (let transformer of transformers) {\n                next = ((next, transformer) => {\n                    return (context) => {\n                        return transformer.call(this, context, next)\n                    }\n                })(next, transformer)\n            }\n            next(context)\n        }\n\n        // given a set of elements with data bind attribute\n        // this renders each of those elements\n        const applyBindings = (bindings) => {\n            for (let bindingEl of bindings) {\n                render(bindingEl)\n            }\n        }\n\n        // this handles the mutation observer changes\n        // if any element is added, and has a data bind attribute\n        // it applies that data binding\n        const updateBindings = (changes) => {\n            for (const change of changes) {\n                if (change.type==\"childList\" && change.addedNodes) {\n                    for (let node of change.addedNodes) {\n                        if (node instanceof HTMLElement) {\n                            let bindings = Array.from(node.querySelectorAll(`[${attribute}]`))\n                            if (node.matches(`[${attribute}]`)) {\n                                bindings.unshift(node)\n                            }\n                            if (bindings.length) {\n                                applyBindings(bindings)\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // this responds to elements getting added to the dom\n        // and if any have data bind attributes, it applies those bindings\n        const observer = new MutationObserver((changes) => {\n            updateBindings(changes)\n        })\n\n        observer.observe(options.container, {\n            subtree: true,\n            childList: true\n        })\n\n        // this finds elements with data binding attributes and applies those bindings\n        // must come after setting up the observer, or included templates\n        // won't trigger their own bindings\n        const bindings = this.options.container.querySelectorAll('['+this.options.attribute+']:not(template)')\n        if (bindings.length) {\n            applyBindings(bindings)\n        }\n\n    }\n\n    /**\n     * Finds the first matching template and creates a new DocumentFragment\n     * with the correct data bind attributes in it (prepends the current path)\n     */\n    applyTemplate(path, templates, list, index) {\n        let template = this.findTemplate(templates, list[index])\n        if (!template) {\n            let result = new DocumentFragment()\n            result.innerHTML = '<!-- no matching template -->'\n            return result\n        }\n        let clone = template.content.cloneNode(true)\n        if (!clone.children?.length) {\n            throw new Error('template must contain a single html element', { cause: template })\n        }\n        if (clone.children.length>1) {\n            throw new Error('template must contain a single root node', { cause: template })\n        }\n        const bindings = clone.querySelectorAll('['+this.options.attribute+']')\n        const attribute = this.options.attribute\n        for (let binding of bindings) {\n            const bind = binding.getAttribute(attribute)\n            if (bind.substring(0, '#root.'.length)=='#root.') {\n                binding.setAttribute(attribute, bind.substring('#root.'.length))\n            } else if (bind=='#value') {\n                binding.setAttribute(attribute, path+'.'+index)\n            } else {\n                binding.setAttribute(attribute, path+'.'+index+'.'+bind)\n            }\n        }\n        clone.children[0].setAttribute(attribute+'-key',index)\n        // keep track of the used template, so if that changes, the \n        // item can be updated\n        clone.children[0].$bindTemplate = template\n        return clone\n    }\n\n    getBindingPath(el) {\n        return el.getAttribute(this.options.attribute)\n    }\n\n    /**\n     * Finds the first template from an array of templates that\n     * matches the given value. \n     */\n    findTemplate(templates, value) {\n        const templateMatches = t => {\n            let path = this.getBindingPath(t)\n            if (!path) {\n                return t\n            }\n            let currentItem\n            if (path.substr(0,6)=='#root.') {\n                currentItem = getValueByPath(this.options.root, path)\n            } else {\n                currentItem = getValueByPath(value, path)\n            }\n            const strItem = ''+currentItem\n            let matches = t.getAttribute(this.options.attribute+'-matches')\n            if (matches) {\n                if (matches==='#empty' && !currentItem) {\n                    return t\n                } else if (matches==='#notempty' && currentItem) {\n                    return t\n                }\n                if (strItem.match(matches)) {\n                    return t\n                }\n            }\n            if (!matches) {\n                if (currentItem) {\n                    return t\n                }\n            }\n        };\n        let template = Array.from(templates).find(templateMatches)\n        let rel = template?.getAttribute('rel')\n        if (rel) {\n            let replacement = document.querySelector('template#'+rel)\n            if (!replacement) {\n                throw new Error('Could not find template with id '+rel)\n            }\n            template = replacement\n        }\n        return template\n    }\n\n}\n\n/**\n * Returns a new instance of SimplyBind. This is the normal start\n * of a data bind flow\n */\nexport function bind(options)\n{\n    return new SimplyBind(options)\n}\n\n/**\n * Returns true if a matches b, either by having the\n * same string value, or matching string #empty against a falsy value\n */\nexport function matchValue(a,b) {\n    if (a=='#empty' && !b) {\n        return true\n    }\n    if (b=='#empty' && !a) {\n        return true\n    }\n    if (''+a == ''+b) {\n        return true\n    }\n    return false\n}\n\n/**\n * Returns the value by walking the given path\n * as a json pointer, starting at root\n * if you have a property with a '.' in its name\n * urlencode the '.', e.g: %46\n */\nexport function getValueByPath(root, path)\n{\n    let parts = path.split('.');\n    let curr = root;\n    let part, prevPart;\n    while (parts.length && curr) {\n        part = parts.shift()\n        if (part=='#key') {\n            return prevPart\n        } else if (part=='#value') {\n            return curr\n        } else if (part=='#root') {\n            curr = root\n        } else {\n            part = decodeURIComponent(part)\n            curr = curr[part];\n            prevPart = part\n        }\n    }\n    return curr\n}\n\n/**\n * Default transformer for data binding\n * Will be used unless overriden in the SimplyBind options parameter\n */\nexport function defaultTransformer(context) {\n    const el = context.element\n    const templates = context.templates\n    const templatesCount = templates.length \n    const path = context.path\n    const value = context.value\n    const attribute = this.options.attribute\n    if (Array.isArray(value) && templates?.length) {\n        transformArrayByTemplates.call(this, context)\n    } else if (value && typeof value == 'object' && templates?.length) {\n        transformObjectByTemplates.call(this, context)\n    } else if (el.tagName=='INPUT') {\n        transformInput.call(this, context)\n    } else if (el.tagName=='BUTTON') {\n        transformButton.call(this, context)\n    } else if (el.tagName=='SELECT') {\n        transformSelect.call(this, context)\n    } else if (el.tagName=='A') {\n        transformAnchor.call(this, context)\n    } else {\n        transformElement.call(this, context)\n    }\n    return context\n}\n\n/**\n * Renders an array value by applying templates for each entry\n * Replaces or removes existing DOM children if needed\n * Reuses (doesn't touch) DOM children if template doesn't change\n */\nexport function transformArrayByTemplates(context) {\n    const el             = context.element\n    const templates      = context.templates\n    const templatesCount = templates.length \n    const path           = context.path\n    const value          = context.value\n    const attribute      = this.options.attribute\n\n    let items = el.querySelectorAll(':scope > ['+attribute+'-key]')\n    // do single merge strategy for now, in future calculate optimal merge strategy from a number\n    // now just do a delete if a key <= last key, insert if a key >= last key\n    let lastKey = 0\n    let skipped = 0\n    for (let item of items) {\n        let currentKey = parseInt(item.getAttribute(attribute+'-key'))\n        if (currentKey>lastKey) {\n            // insert before\n            el.insertBefore(this.applyTemplate(path, templates, value, lastKey), item)\n        } else if (currentKey<lastKey) {\n            // remove this\n            item.remove()\n        } else {\n            // check that all data-bind params start with current json path or a '#', otherwise replaceChild\n            let bindings = Array.from(item.querySelectorAll(`[${attribute}]`))\n            if (item.matches(`[${attribute}]`)) {\n                bindings.unshift(item)\n            }\n            let needsReplacement = bindings.find(b => {\n                let databind = b.getAttribute(attribute)\n                return (databind.substr(0,5)!=='#root' \n                    && databind.substr(0, path.length)!==path)\n            })\n            if (!needsReplacement) {\n                if (item.$bindTemplate) {\n                    let newTemplate = this.findTemplate(templates, value[lastKey])\n                    if (newTemplate != item.$bindTemplate){\n                        needsReplacement = true\n                        if (!newTemplate) {\n                            skipped++\n                        }\n                    }\n                }\n            }\n            if (needsReplacement) {\n                el.replaceChild(this.applyTemplate(path, templates, value, lastKey), item)\n            }\n        }\n        lastKey++\n        if (lastKey>=value.length) {\n            break\n        }\n    }\n    items = el.querySelectorAll(':scope > ['+attribute+'-key]')\n    let length = items.length + skipped\n    if (length > value.length) {\n        while (length > value.length) {\n            let child = el.querySelectorAll(':scope > :not(template)')?.[length-1]\n            child?.remove()\n            length--\n        }\n    } else if (length < value.length ) {\n        while (length < value.length) {\n            el.appendChild(this.applyTemplate(path, templates, value, length))\n            length++\n        }\n    }\n}\n\n/**\n * Renders an object value by applying templates for each entry (Object.entries)\n * Replaces or removes existing DOM children if needed\n * Reuses (doesn't touch) DOM children if template doesn't change\n */\nexport function transformObjectByTemplates(context) {\n    const el             = context.element\n    const templates      = context.templates\n    const templatesCount = templates.length \n    const path           = context.path\n    const value          = context.value\n    const attribute      = this.options.attribute\n    \n    let list    = Object.entries(value)\n    let items   = el.querySelectorAll(':scope > ['+attribute+'-key]')\n    let current = 0\n    let skipped = 0\n    for (let item of items) {\n        if (current>=list.length) {\n            break\n        }\n        let key = list[current][0]\n        current++\n        let keypath = path+'.'+key\n        // check that all data-bind params start with current json path or a '#', otherwise replaceChild\n        let needsReplacement\n        const databind = item.getAttribute(attribute)\n        if (databind && databind.substr(0, keypath.length)!=keypath) {\n            needsReplacement=true\n        } else {\n            let bindings = Array.from(item.querySelectorAll(`[${attribute}]`))\n            needsReplacement = bindings.find(b => {\n                const db = b.getAttribute(attribute)\n                return (db.substr(0,5)!=='#root' && db.substr(0, keypath.length)!==keypath)\n            })\n            if (!needsReplacement) {\n                if (item.$bindTemplate) {\n                    let newTemplate = this.findTemplate(templates, value[key])\n                    if (newTemplate != item.$bindTemplate){\n                        needsReplacement = true\n                        if (!newTemplate) {\n                            skipped++\n                        }\n                    }\n                }\n            }\n        }\n        if (needsReplacement) {\n            let clone = this.applyTemplate(path, templates, value, key)\n            el.replaceChild(clone, item)\n        }\n    }\n    items  = el.querySelectorAll(':scope > ['+attribute+'-key]')\n    let length = items.length + skipped\n    if (length>list.length) {\n        while (length>list.length) {\n            let child = el.querySelectorAll(':scope > :not(template)')?.[length-1]\n            child?.remove()\n            length--\n        }\n    } else if (length < list.length) {\n        while (length < list.length) {\n            let key = list[length][0]\n            el.appendChild(this.applyTemplate(path, templates, value, key))\n            length++\n        }\n    } \n}\n\n/**\n * transforms a single input type\n * for radio/checkbox inputs it only sets the checked attribute to true/false\n * if the value attribute matches the current value\n * for other inputs the value attribute is updated\n * FIXME: handle radio/checkboxes in separate transformer\n */\nexport function transformInput(context) {\n    const el    = context.element\n    const value = context.value\n\n    if (el.type=='checkbox' || el.type=='radio') {\n        if (matchValue(el.value, value)) {\n            el.checked = true\n        } else {\n            el.checked = false\n        }\n    } else if (!matchValue(el.value, value)) {\n        el.value = ''+value\n    }\n}\n\n/**\n * Sets the value of the button, doesn't touch the innerHTML\n */\nexport function transformButton(context) {\n    const el    = context.element\n    const value = context.value\n\n    if (!matchValue(el.value,value)) {\n        el.value = ''+value\n    }\n}\n\n/**\n * Sets the selected attribute of select options\n */\nexport function transformSelect(context) {\n    const el    = context.element\n    const value = context.value\n\n    if (el.multiple) {\n        if (Array.isArray(value)) {\n            for (let option of el.options) {\n                if (value.indexOf(option.value)===false) {\n                    option.selected = false\n                } else {\n                    option.selected = true\n                }\n            }\n        }\n    } else {\n        let option = el.options.find(o => matchValue(o.value,value))\n        if (option) {\n            option.selected = true\n        }\n    }\n}\n\n/**\n * Sets the innerHTML and href attribute of an anchor\n * TODO: support target, title, etc. attributes\n */\nexport function transformAnchor(context) {\n    const el    = context.element\n    const value = context.value\n\n    if (value?.innerHTML && !matchValue(el.innerHTML, value.innerHTML)) {\n        el.innerHTML = ''+value.innerHTML\n    }\n    if (value?.href && !matchValue(el.href,value.href)) {\n        el.href = ''+value.href\n    }    \n}\n\n/**\n * sets the innerHTML of any HTML element\n */\nexport function transformElement(context) {\n    const el    = context.element\n    const value = context.value\n\n    if (!matchValue(el.innerHTML, value)) {\n        el.innerHTML = ''+value\n    }\n}", "import { routes } from './route.mjs'\nimport { commands } from './command.mjs'\nimport { actions } from './action.mjs'\nimport { keys } from './key.mjs'\nimport { signal } from './state.mjs'\nimport { bind } from './bind.mjs'\n\nclass SimplyApp {\n\tconstructor(options={}) {\n\t\tthis.container = options.container || document.body\n\t\tif (!options.state) {\n\t\t\toptions.state = {}\n\t\t}\n\t\tthis.state = signal(options.state)\n\t\tif (options.commands) {\n\t\t\tthis.commands = commands({ app: this, container: this.container, commands: options.commands})\n\t\t}\n\t\tif (options.keys) {\n\t\t\tthis.keys = keys({ app: this, keys: options.keys })\n\t\t}\n\t\tif (options.routes) {\n\t\t\tthis.routes = routes({ app: this, routes: options.routes})\n\t\t}\n\t\tif (options.actions) {\n\t\t\tthis.actions = actions({app: this, actions: options.actions})\n\t\t}\n\t\tlet bindOptions = { container: this.container, root: this.state } \n\t\tif (options.defaultTransformers) {\n\t\t\tbindOptions.defaultTransformers = options.defaultTransformers\n\t\t}\n\t\tif (options.transformers) {\n\t\t\tbindOptions.transformers = options.transformers\n\t\t}\n\t\tthis.bind = bind(bindOptions)\n\t}\n}\n\nexport function app(options={}) {\n\treturn new SimplyApp(options)\n}", "function throttle( callbackFunction, intervalTime ) {\n    let eventId = 0\n    return () => {\n        const myArguments = arguments\n        if ( eventId ) {\n            return\n        } else {\n            eventId = globalThis.setTimeout( () => {\n                callbackFunction.apply(this, myArguments)\n                eventId = 0\n            }, intervalTime )\n        }\n    }\n}\n\nconst runWhenIdle = (() => {\n    if (globalThis.requestIdleCallback) {\n        return (callback) => {\n            globalThis.requestIdleCallback(callback, {timeout: 500})\n        }\n    }\n    return globalThis.requestAnimationFrame\n})()\n\nfunction rebaseHref(relative, base) {\n    let url = new URL(relative, base)\n    if (include.cacheBuster) {\n        url.searchParams.set('cb',include.cacheBuster)\n    }\n    return url.href\n}\n\nlet observer, loaded = {}\nlet head = globalThis.document.querySelector('head')\nlet currentScript = globalThis.document.currentScript\nlet getScriptURL, currentScriptURL\nif (!currentScript) {\n    getScriptURL = (() => {\n        var scripts = document.getElementsByTagName('script')\n        var index = scripts.length - 1\n        var myScript = scripts[index]\n        return () => myScript.src\n    })()\n    currentScriptURL = getScriptURL()\n} else {\n    currentScriptURL = currentScript.src\n}\n\nconst waitForPreviousScripts = async () => {\n    // because of the async=false attribute, this script will run after\n    // the previous scripts have been loaded and run\n    // simply.include.next.js only fires the simply-next-script event\n    // that triggers the Promise.resolve method\n    return new Promise(function(resolve) {\n        var next = globalThis.document.createElement('script')\n        next.src = rebaseHref('simply.include.next.js', currentScriptURL)\n        next.async = false\n        globalThis.document.addEventListener('simply-include-next', () => {\n            head.removeChild(next)\n            resolve()\n        }, { once: true, passive: true})\n        head.appendChild(next)\n    })\n}\n\nlet scriptLocations = []\n\nexport const include = {\n    cacheBuster: null,\n    scripts: (scripts, base) => {\n        let arr = scripts.slice()\n        const importScript = () => {\n            const script = arr.shift()\n            if (!script) {\n                return\n            }\n            const attrs  = [].map.call(script.attributes, (attr) => {\n                return attr.name\n            })\n            let clone  = globalThis.document.createElement('script')\n            for (const attr of attrs) {\n                clone.setAttribute(attr, script.getAttribute(attr))\n            }\n            clone.removeAttribute('data-simply-location')\n            if (!clone.src) {\n                // this is an inline script, so copy the content and wait for previous scripts to run\n                clone.innerHTML = script.innerHTML\n                waitForPreviousScripts()\n                    .then(() => {\n                        const node = scriptLocations[script.dataset.simplyLocation]\n                        node.parentNode.insertBefore(clone, node)\n                        node.parentNode.removeChild(node)\n                        importScript()\n                    })\n            } else {\n                clone.src = rebaseHref(clone.src, base)\n                if (!clone.hasAttribute('async') && !clone.hasAttribute('defer')) {\n                    clone.async = false //important! do not use clone.setAttribute('async', false) - it has no effect\n                }\n                const node = scriptLocations[script.dataset.simplyLocation]\n                node.parentNode.insertBefore(clone, node)\n                node.parentNode.removeChild(node)\n                loaded[clone.src]=true\n                importScript()\n            }\n        }\n        if (arr.length) {\n            importScript()\n        }\n    },\n    html: (html, link) => {\n        let fragment = globalThis.document.createRange().createContextualFragment(html)\n        const stylesheets = fragment.querySelectorAll('link[rel=\"stylesheet\"],style')\n        // add all stylesheets to head\n        for (let stylesheet of stylesheets) {\n            if (stylesheet.href) {\n                stylesheet.href = rebaseHref(stylesheet.href, link.href)\n            }\n            head.appendChild(stylesheet)\n        }\n        // remove the scripts from the fragment, as they will not run in the\n        // order in which they are defined\n        let scriptsFragment = globalThis.document.createDocumentFragment()\n        const scripts = fragment.querySelectorAll('script')\n        for (let script of scripts) {\n            let placeholder = globalThis.document.createComment(script.src || 'inline script')\n            script.parentNode.insertBefore(placeholder, script)\n            script.dataset.simplyLocation = scriptLocations.length\n            scriptLocations.push(placeholder)\n            scriptsFragment.appendChild(script)\n        }\n        // add the remainder before the include link\n        link.parentNode.insertBefore(fragment, link ? link : null)\n        globalThis.setTimeout(function() {\n            include.scripts(scriptsFragment.childNodes, link ? link.href : globalThis.location.href )\n        }, 10)\n    }\n}\n\nlet included = {}\nconst includeLinks = async (links) => {\n    // mark them as in progress, so handleChanges doesn't find them again\n    let remainingLinks = [].reduce.call(links, (remainder, link) => {\n        if (link.rel=='simply-include-once' && included[link.href]) {\n            link.parentNode.removeChild(link)\n        } else {\n            included[link.href]=true\n            link.rel = 'simply-include-loading'\n            remainder.push(link)\n        }\n        return remainder\n    }, [])\n\n    for (let link of remainingLinks) {\n        if (!link.href) {\n            return\n        }\n        // fetch the html\n        const response = await fetch(link.href)\n        if (!response.ok) {\n            console.log('simply-include: failed to load '+link.href);\n            continue\n        }\n        console.log('simply-include: loaded '+link.href);\n        const html = await response.text()\n        // if succesfull import the html\n        include.html(html, link)\n        // remove the include link\n        link.parentNode.removeChild(link)\n    }\n}\n\nconst handleChanges = throttle(() => {\n    runWhenIdle(() => {\n        var links = globalThis.document.querySelectorAll('link[rel=\"simply-include\"],link[rel=\"simply-include-once\"]')\n        if (links.length) {\n            includeLinks(links)\n        }\n    })\n})\n\nconst observe = () => {\n    observer = new MutationObserver(handleChanges)\n    observer.observe(globalThis.document, {\n        subtree: true,\n        childList: true,\n    })\n}\n\nobserve()\nhandleChanges() // check if there are include links in the dom already\n", "import {signal, effect, batch} from './state.mjs'\n\n/**\n * This class implements a pluggable data model, where you can\n * add effects that are run only when either an option for that\n * effect changes, or when an effect earlier in the chain of\n * effects changes.\n */\nclass SimplyModel {\n\n\t/**\n\t * Creates a new datamodel, with a state property that contains\n\t * all the data passed to this constructor\n\t * @param state\tObject with all the data for this model\n\t */\n\tconstructor(state) {\n\t\tthis.state = signal(state)\n\t\tif (!this.state.options) {\n\t\t\tthis.state.options = {}\n\t\t}\n\t\tthis.effects = [{current:state.data}]\n\t\tthis.view = signal(state.data)\n\t}\n\n\t/**\n\t * Adds an effect to run whenever a signal it depends on\n\t * changes. this.state is the usual signal.\n\t * The `fn` function param is not itself an effect, but must return\n\t * and effect function. `fn` takes one param, which is the data signal.\n\t * This signal will always have at least a `current` property.\n\t * The result of the effect function is pushed on to the this.effects\n\t * list. And the last effect added is set as this.view\n\t */\n\taddEffect(fn) {\n\t\tconst dataSignal = this.effects[this.effects.length-1]\n\t\tthis.view = fn.call(this, dataSignal)\n\t\tthis.effects.push(this.view)\n\t}\n}\n\nexport function model(options) {\n\treturn new SimplyModel(options)\n}\n\nexport function sort(options={}) {\n\treturn function(data) {\n\t\t// initialize the sort options, only gets called once\n\t\tthis.state.options.sort = Object.assign({\n\t\t\tdirection: 'asc',\n\t\t\tsortBy: null,\n\t\t\tsortFn: ((a,b) => {\n\t\t\t\tconst sort = this.state.options.sort\n\t\t\t\tconst sortBy = sort.sortBy\n\t\t\t\tif (!sort.sortBy) {\n\t\t\t\t\treturn 0\n\t\t\t\t}\n\t\t\t\tconst larger = sort.direction == 'asc' ? 1 : -1\n\t\t\t\tconst smaller = sort.direction == 'asc' ? -1 : 1\n\t\t\t\tif (typeof a?.[sortBy] === 'undefined') {\n\t\t\t\t\tif (typeof b?.[sortBy] === 'undefined') {\n\t\t\t\t\t\treturn 0\n\t\t\t\t\t}\n\t\t\t\t\treturn larger\n\t\t\t\t}\n\t\t\t\tif (typeof b?.[sortBy] === 'undefined') {\n\t\t\t\t\treturn smaller\n\t\t\t\t}\n\t\t\t\tif (a[sortBy]<b[sortBy]) {\n\t\t\t\t\treturn smaller\n\t\t\t\t} else if (a[sortBy]>b[sortBy]) {\n\t\t\t\t\treturn larger\n\t\t\t\t} else {\n\t\t\t\t\treturn 0\n\t\t\t\t}\n\t\t\t})\n\t\t}, options);\n\t\t// then return the effect, which is called when\n\t\t// either the data or the sort options change\n\t\treturn effect(() => {\n\t\t\tconst sort = this.state.options.sort\n\t\t\tif (sort?.sortBy && sort?.direction) {\n\t\t\t\treturn data.current.toSorted(sort?.sortFn)\n\t\t\t}\n\t\t\treturn data.current\n\t\t})\n\t}\n}\n\nexport function paging(options={}) {\n\treturn function(data) {\n\t\t// initialize the paging options\n\t\tthis.state.options.paging = Object.assign({\n\t\t\tpage: 1,\n\t\t\tpageSize: 20,\n\t\t\tmax: 1\n\t\t}, options)\n\t\treturn effect(() => {\n\t\t\treturn batch(() => {\n\t\t\t\tconst paging = this.state.options.paging\n\t\t\t\tif (!paging.pageSize) {\n\t\t\t\t\tpaging.pageSize = 20\n\t\t\t\t}\n\t\t\t\tpaging.max = Math.ceil(this.state.data.length / paging.pageSize)\n\t\t\t\tpaging.page = Math.max(1, Math.min(paging.max, paging.page))\n\n\t\t\t\tconst start = (paging.page-1) * paging.pageSize\n\t\t\t\tconst end = start + paging.pageSize\n\t\t\t\treturn data.current.slice(start, end)\n\t\t\t})\n\t\t})\n\t}\n}\n\nexport function filter(options) {\n\tif (!options?.name || typeof options.name!=='string') {\n\t\tthrow new Error('filter requires options.name to be a string')\n\t}\n\tif (!options.matches || typeof options.matches!=='function') {\n\t\tthrow new Error('filter requires options.matches to be a function')\n\t}\n\treturn function(data) {\n\t\tthis.state.options[options.name] = options\n\t\treturn effect(() => {\n\t\t\tif (this.state.options[options.name].enabled) {\n\t\t\t\treturn data.filter(this.state.options.matches)\n\t\t\t}\n\t\t})\n\t}\n}\n\nexport function columns(options={}) {\n\tif (!options\n\t\t|| typeof options!=='object'\n\t\t|| Object.keys(options).length===0) {\n\t\tthrow new Error('columns requires options to be an object with at least one property')\n\t}\n\treturn function(data) {\n\t\tthis.state.options.columns = options\n\t\treturn effect(() => {\n\t\t\treturn data.current.map(input => {\n\t\t\t\tlet result = {}\n\t\t\t\tfor (let key of Object.keys(this.state.options.columns)) {\n\t\t\t\t\tif (!this.state.options.columns[key].hidden) {\n\t\t\t\t\t\tresult[key] = input[key]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result\n\t\t\t})\n\t\t})\n\t}\n}", "import { activate } from './activate.mjs'\nimport * as action from './action.mjs'\nimport { app } from './app.mjs'\nimport { bind } from './bind.mjs'\nimport * as command from './command.mjs'\nimport { include } from './include.mjs'\nimport * as key from './key.mjs'\nimport * as model from './model.mjs'\nimport * as route from './route.mjs'\nimport * as state from './state.mjs'\n\nexport const simply = {\n\tactivate,\n\taction,\n\tapp,\n\tbind,\n\tcommand,\n\tinclude,\n\tkey,\n\tmodel,\n\troute,\n\tstate\n}\n\nwindow.simply = simply"],
  "mappings": "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",
  "names": ["listeners", "activate", "name", "callback", "initialCall", "listener", "nodes", "node", "callListeners", "handleChanges", "changes", "activateNodes", "change", "toActivate", "observer", "action_exports", "__export", "actions", "SimplyActions", "options", "actionHandler", "target", "property", "route_exports", "__export", "routes", "options", "SimplyRoute", "parseRoutes", "path", "args", "matches", "getPath", "route", "params", "key", "i", "action", "routeRe", "getRegexpFromRoute", "result", "callback", "evt", "link", "getURL", "listener", "root", "routeInfo", "paths", "matchParams", "command_exports", "__export", "commands", "SimplyCommands", "options", "defaultHandlers", "commandHandler", "evt", "command", "getCommand", "stop", "fn", "handlers", "el", "handler", "values", "option", "data", "input", "key_exports", "__export", "keys", "SimplyKeys", "options", "selectedKeyboard", "key", "state_exports", "__export", "batch", "clockEffect", "destroy", "effect", "signal", "throttledEffect", "untracked", "source", "iterate", "signalHandler", "target", "property", "receiver", "value", "notifyGet", "args", "l", "result", "notifySet", "makeContext", "s", "current", "signals", "descriptor", "v", "batchedListeners", "batchMode", "self", "context", "listeners", "change", "propListeners", "getListeners", "listener", "addContext", "currentEffect", "computeStack", "clearContext", "prop", "currentCompute", "setListeners", "listenersMap", "computeMap", "compute", "connectedSignals", "clearListeners", "effectStack", "effectMap", "signalStack", "fn", "f", "connectedSignal", "computeEffect", "runBatchedListeners", "copyBatchedListeners", "throttleTime", "throttled", "hasChange", "clock", "lastTick", "hasChanged", "remember", "SimplyBind", "options", "defaultOptions", "defaultTransformer", "attribute", "render", "el", "throttledEffect", "context", "getValueByPath", "runTransformers", "transformers", "t", "next", "transformer", "applyBindings", "bindings", "bindingEl", "updateBindings", "changes", "change", "node", "path", "templates", "list", "index", "template", "result", "clone", "binding", "bind", "value", "templateMatches", "currentItem", "strItem", "matches", "rel", "replacement", "matchValue", "a", "b", "root", "parts", "curr", "part", "prevPart", "templatesCount", "transformArrayByTemplates", "transformObjectByTemplates", "transformInput", "transformButton", "transformSelect", "transformAnchor", "transformElement", "items", "lastKey", "skipped", "item", "currentKey", "needsReplacement", "databind", "newTemplate", "length", "current", "key", "keypath", "db", "option", "o", "SimplyApp", "options", "signal", "commands", "keys", "routes", "actions", "bindOptions", "bind", "app", "throttle", "callbackFunction", "intervalTime", "eventId", "myArguments", "runWhenIdle", "callback", "rebaseHref", "relative", "base", "url", "include", "observer", "loaded", "head", "currentScript", "getScriptURL", "currentScriptURL", "scripts", "index", "myScript", "waitForPreviousScripts", "resolve", "next", "scriptLocations", "arr", "importScript", "script", "attrs", "attr", "clone", "node", "html", "link", "fragment", "stylesheets", "stylesheet", "scriptsFragment", "placeholder", "included", "includeLinks", "links", "remainingLinks", "remainder", "response", "handleChanges", "observe", "model_exports", "__export", "columns", "filter", "model", "paging", "sort", "SimplyModel", "state", "signal", "fn", "dataSignal", "model", "options", "sort", "data", "a", "b", "sortBy", "larger", "smaller", "effect", "paging", "batch", "start", "end", "filter", "columns", "input", "result", "key", "simply", "activate", "action_exports", "app", "bind", "command_exports", "include", "key_exports", "model_exports", "route_exports", "state_exports"]
}
