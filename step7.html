<h1>one way and two way databinding to multiple fields with simple api</h1>
<h2>custom field types with setters/getters and complex objects as value</h2>
<script>
var simply = (function(simply) {

	/*** utility functions ****/	
	function throttle( callbackFunction, intervalTime ) {
		var eventId = 0;
		return function() {
			var myArguments = arguments;
			var me = this;
			if ( eventId ) {
				return;
			} else {
				eventId = window.setTimeout( function() {
					callbackFunction.apply(me, myArguments);
					eventId = 0;
				}, intervalTime );
			}
		}
	}

	function getElement(node) {
		if (node.nodeType != Node.ELEMENT_NODE) {
			return node.parentElement;
		}
		return node;
	}

	function getByPath(model, path) {
		if (!path) {
			return model;
		}
		return path.split('.').reduce(function(acc, name) {
			return (acc && acc[name] ? acc[name] : null);
		}, model);
	}

	function getLastKey(path) {
		return path.split('.').pop();
	}

	function updateValue(model, path, value) {
		var pathNames = path.split('.');
		var last = pathNames.pop();
		var parentOb = pathNames.reduce(function(acc, name) {
			if (!acc[name]) {
				// attach chain is broken here, repair it
				acc[name] = {}
			}
			return acc[name];
		}, model);
		parentOb[last] = value;
	}

	/*** functions that should be configurable ****/
	function getPath(el) {
		return el.dataset.bind;
	}

	function setValue(el, value, binding) {
		if (el!=focusedElement) {
			var setters = Object.keys(binding.fieldTypes);
			for(var i=setters.length-1;i>=0;i--) {
				if (el.matches(setters[i])) {
					binding.fieldTypes[setters[i]].set.call(el, (typeof value != 'undefined' ? value : ''));
					return;
				}
			}
		}
	}

	function getValue(el, binding) {
		var setters = Object.keys(binding.fieldTypes);
		for(var i=setters.length-1;i>=0;i--) {
			if (el.matches(setters[i])) {
				return binding.fieldTypes[setters[i]].get.call(el);
			}
		}
	}

	/*** shadow values ***/
	var shadows = new WeakMap();
	var focusedElement = null;
	/**
	 * Returns an object ment to keep the original value of model[jsonPath]
	 */
	function getShadow(model, jsonPath) {
		if (!shadows.has(model)) {
			shadows.set(model, {});
		}
		var root = shadows.get(model);
		if (typeof root[jsonPath] == 'undefined') {
			root[jsonPath] = {
				value: null,
				elements: [],
				children: {}
			};
		}
		return root[jsonPath];
	}

	/**
	 * Returns true if a shadow for this path and rootModel exist
	 * This means that there is already a setter/getter pair for it.
	 **/
	function hasShadow(model, jsonPath) {
		if (!shadows.has(model)) {
			shadows.set(model, {});
		}
		var root = shadows.get(model);
		return typeof root[jsonPath] != 'undefined';
	}

	function Binding(config) {
		this.config = config;
		if (!this.config) {
			this.config = {};
		}
		if (!this.config.model) {
			this.config.model = {};
		}
		if (!this.config.selector) {
			this.config.selector = '[data-bind]';
		}
		this.fieldTypes = {
			'*': {
				set: function(value) {
					this.innerHTML = value;
				},
				get: function() {
					return this.innerHTML;
				}
			}
		};
		if (this.config.fieldTypes) {
			Object.assign(this.fieldTypes, this.config.fieldTypes);
		}
		this.attach(document.querySelectorAll(this.config.selector));
	};

	Binding.prototype.attach = function(elements) {
		var self = this;

		/**
		 * Attaches a binding to a specific html element.
		 **/
		var attachElement = function(jsonPath, el) {
			if (!document.body.contains(el)) {
				// element is no longer part of the document
				// so don't bother changing the model or updating the element for it
				return;
			}
			var keys       = jsonPath.split('.'),
			    parentPath = '',
			    path       = '',
			    shadow,
			    model      = self.config.model;

			do {
				key    = keys.shift();
				path   = (parentPath ? parentPath + '.' : '') + key;
				shadow = getShadow(self.config.model, path);
				if (keys.length) {
					shadow.children[ path + '.' + keys[0]] = true;
				}
				if (model && typeof model == 'object') {
					shadow.value = model[key];
					Object.defineProperty(model, key, {
						set: (function(shadow, path) {
							return function(value) {
								shadow.value = value;
								updateElements(shadow.elements, value);
								attachChildren(shadow);
								addSetTriggers(shadow);
								updateParents(path);
								monitorProperties(value, path);
							};
						})(shadow, path),
						get: (function(shadow) {
							return function() {
								return shadow.value;
							}
						})(shadow),
						configurable: true,
						enumerable: true
					});
					model = model[key];
				}
				parentPath = path;
			} while(keys.length);
			if (shadow.elements.indexOf(el)==-1) {
				shadow.elements.push(el);
			}
			initElement(el);
			updateElements([el], model);
			monitorProperties(model, path);
		};

		/**
		 * This will call updateElements on all parents of jsonPath that are
		 * bound to some elements.
		 **/
		var updateParents = function(jsonPath) {
			var keys = jsonPath.split('.'), 
				path;
			do {
				path = keys.join('.');
				keys.pop();
				shadow = getShadow(self.config.model, path);
				if (shadow && shadow.elements.length) {
					updateElements(shadow.elements, shadow.value);
				}
			} while(keys.length);
		};

		/**
		 * This defines setters/getters for properties that aren't bound
		 * to elements directly, but who have a parent object that is.
		 **/
		var monitorProperties = function(model, path) {
			if (!model || typeof model != 'object') {
				return;
			}

			var _shadow = {};
			Object.getOwnPropertyNames(model).forEach(function(property) {
				if (!hasShadow(self.config.model, path+'.'+property)) {
					// If the property has a shadow, then it is already bound
					// and has a setter that will call updateParents
					_shadow[property] = model[property];
					Object.defineProperty(model, property, {
						set: function(value) {
							_shadow[property] = value;
							updateParents(path);
						},
						get: function() {
							return _shadow[property];
						},
						configurable: true,
						enumerable: true
					});
				}
				if (model[property] && typeof model[property] == 'object') {
					monitorProperties(model[property], path+'.'+property);
				}
			});
		}
		
		/**
		 * Runs the init() method of the fieldType, if it is defined.
		 **/
		var initElement = function(el) {
			var selectors = Object.keys(self.fieldTypes);
			for (var i=selectors.length-1; i>=0; i--) {
				if (self.fieldTypes[selectors[i]].init && el.matches(selectors[i])) {
					self.fieldTypes[selectors[i]].init.call(el);
					return;
				}
			}
		};

		/**
		 * Updates the given elements with the new value, if the element is still
		 * in the document.body. Otherwiste it will remove the element from the
		 * elements list. During the update the observer is paused.
		 **/
		var updateElements = function(elements, value) {
			var reconnectObserver;
			if (self.observing) {
				self.observer.disconnect();
				self.observing = false;
				reconnectObserver = true;
			}
			elements.forEach(function(el, index) {
				if (document.body.contains(el)) {
					setValue(el, value, self);
				} else {
					elements.splice(index,1);
				}
			});
			if (reconnectObserver) {
		        self.observing = true;
				self.observer.observe(document.body, {
		        	subtree: true,
		        	childList: true,
		        	characterData: true,
		        	attributes: true	
		        });
		    }
		};

		/**
		 * Loops over registered children of the shadow, that means a sub property
		 * is bound to an element, and reattaches those to their elements with the
		 * new values.
		 **/
		var attachChildren = function( shadow) {
			Object.keys(shadow.children).forEach(function(child) {
				var value = getByPath(self.config.model, child);
				var childShadow = getShadow(self.config.model, child);
				childShadow.value = value;
				childShadow.elements.forEach(function(el) {
					attachElement(child, el);
				});
			});
		};

		/**
		 * Adds a setter for all bound child properties that restores the bindings
		 * when a new value is set for them. This is to restore bindings after a
		 * parent value is changed so the original property is no longer set.
		 * It is not enumerable, so it won't show up in Object.keys or JSON.stringify
		 **/
		var addSetTriggers = function(shadow){
			Object.keys(shadow.children).forEach(function(childPath) {
				var name = getLastKey(childPath);
				if (shadow.value && typeof shadow.value[name] == 'undefined') {
					Object.defineProperty(shadow.value, name, {
						set: function(value) {
							restoreBinding(childPath);
							shadow.value[name] = value;
						},
						configurable: true,
						enumerable: false
					});
				}
			});
		}

		/**
		 * Restores the binding for all registered bound elements.
		 * Run when the set trigger is called.
		 **/
		var restoreBinding = function(path) {
			var shadow = getShadow(self.config.model, path);
			[].forEach.call(shadow.elements, function(element) {
            	attachElement(path, element);
        	});
		}

		if ( elements instanceof HTMLElement ) {
			elements = [ elements ];
		}
		[].forEach.call(elements, function(element) {
            var key = getPath(element);
            attachElement(key, element);
        });
        document.body.addEventListener('simply.bind.update', function(evt) {
			focusedElement = evt.target;
			updateValue(self.config.model, getPath(evt.target), getValue(evt.target, self));
			focusedElement = null;
        }, true);
	};

	Binding.prototype.observe = function(root) {
		var changes = [];
		var self    = this;

		var handleChanges = throttle(function() {
			changes = changes.concat(self.observer.takeRecords());
			self.observer.disconnect();
			self.observing = false;
			var change,el;
			var handled = {}; // list of keys already handled
			for (var i=changes.length-1; i>=0; i--) {
				// handle last change first, so programmatic changes are predictable
				// last change overrides earlier changes
				change = changes[i];
				el = getElement(change.target);
				if (el && !el.matches(self.config.selector)) {
					el = el.closest(self.config.selector);
				}
				if (el) {
					var key = getPath(el);
					if (handled[key]) {
						// we already handled this key, the model is uptodate
						continue;
					}
					handled[key] = true;
					focusedElement = el;
					updateValue(self.config.model, key, getValue(el, self));
					focusedElement = null;
				}
			}
			self.observing = true;
			self.observer.observe(root, {
	        	subtree: true,
	        	childList: true,
	        	characterData: true,
	        	attributes: true				
			});
		},100);
        this.observer = new MutationObserver(function(changeList) {
        	changes = changes.concat(changeList);
        	handleChanges();
        });
        this.observing = true;
        this.observer.observe(root, {
        	subtree: true,
        	childList: true,
        	characterData: true,
        	attributes: true	
        });
        return this.observer;
	};

	Binding.prototype.stopObserver = function() {
		this.observer.disconnect();
		this.observing = false;
	};

	simply.bind = function(config) {
		return new Binding(config);
	};

    return simply;
})(simply || {});
</script>

</script>

<h1 contenteditable=true data-bind="title">title</h1>
<p contenteditable=true data-bind="description">description</p>
<div><label>Name:</label><span contenteditable="true" data-bind="user.name"></span></div>
<div><label>Email:</label><span contenteditable="true" data-bind="user.email"></span></div>
<pre contenteditable=true data-bind="title"></pre>
<a href="bla" title="foo" data-bind="link" contenteditable=true>Link</a>
<input type="text" name="foo" data-bind="input" value="bar">
<script>
  window.model = {
    title: "A nice title",
    user: {
      name: "Mr. User",
      email: "user@example.org"
    },
    link: {
    	href: 'https://www.muze.nl/',
    	title: 'Muze',
    	innerHTML: 'Link naar Muze'
    },
    input: 'waarde'
  };
  
  var bindings = simply.bind({
  	model: window.model,
	fieldTypes: {
		'a': {
			init: function() {
			},
			set: function(value) {
				this.href = value && value.href ? value.href : '';
				this.title = value && value.title ? value.title : '';
				this.innerHTML = value && value.innerHTML ? value.innerHTML : '';
			},
			get: function() {
				return {
					href: this.href,
					title: this.title,
					innerHTML: this.innerHTML
				}
			}
		},
		'input[type=text]': {
			init: function() {
				this.addEventListener('input', function(evt) {
					this.dispatchEvent(new Event('simply.bind.update', {
						bubbles: true,
						cancelable: true
					}));
				});
			},
			set: function(value) {
				this.value = value;
			},
			get: function() {
				return this.value;
			}
		}
	}
  }).observe(document.body);
</script>
<h2>Try:</h2>
<pre>
    model.link.href = "foo";
    model.link = null;
    model.link = { href: '//muze.nl/', title: 'Muze', innerHTML: 'Muze' };
</pre>
<pre>
var bindings = simply.bind({
	model: model,
	selector: '[data-bind]',
	fieldTypes: {
		'a': {
			set: function(value) {
				this.href = value.href;
				this.title = value.title;
				this.innerHTML = value.innerHTML;
			},
			get: function() {
				return {
					href: this.href,
					title: this.title,
					innerHTML: this.innerHTML
				}
			}
		},
		'input[type=text]': {
			init: function() {
				this.addEventListener('input', function(evt) {
					this.dispatchEvent(new Event('simply.bind.update', {
						bubbles: true,
						cancelable: true
					}));
				});
			},
			set: function(value) {
				this.value = value;
			},
			get: function() {
				return this.value;
			}
		}
	}
});
.observe(document.body);

</pre>